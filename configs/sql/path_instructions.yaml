# PostgreSQL / CloudSQL Best Practices
- path: "**/{postgres,cloudsql,db,database,sql,psql}*/**"
  instructions: |
    **Comprehensive PostgreSQL/CloudSQL Code Review Checklist:**
    
    **ğŸ›¡ï¸ Security & Injection Prevention:**
    1. **SQL Injection Prevention:**
       - âœ… **Always use parameterized queries** to prevent SQL injection
       - âœ… Use prepared statements for repeated queries
       - âœ… Never concatenate user input directly into SQL strings
       - âœ… Use ORM query builders when possible for additional safety
       - âš ï¸ **Critical**: Flag any string concatenation in SQL queries
    
    **ğŸš€ Performance & Query Optimization:**
    2. **Query Performance Analysis:**
       - âœ… **N+1 Query Detection**: Look for loops that execute database queries
       - âœ… **Batching**: Use `IN` clauses or batch operations instead of individual queries
    
    3. **Performance Anti-Patterns:**
       - âŒ **FULL SCAN**: Avoid table scans on large tables
       - âŒ **CARTESIAN JOIN**: Never use cross joins without explicit WHERE conditions
       - âŒ **SELECT ***: Always specify required columns explicitly
       - âŒ **Subqueries in SELECT**: Use JOINs when possible
       - âŒ **Functions on indexed columns**: Avoid applying functions to indexed columns
    
    
    **ğŸ”Œ Connection & Resource Management:**
    4. **Connection Management:**
       - âœ… Use connection pooling (PgBouncer, application-level pools)
       - âœ… Configure appropriate pool size based on application load
       - âœ… Set connection timeouts and idle connection limits
       - âœ… Implement proper connection cleanup and error handling
       - âœ… Monitor connection pool utilization and health
    
    5. **Resource Cleanup:**
       - âœ… Always close database connections after use
       - âœ… Use try-with-resources or defer statements for cleanup
       - âœ… Implement proper error handling with connection cleanup
       - âœ… Monitor for connection leaks and resource exhaustion
       - âœ… Handle connection failures gracefully with retry logic
    
    **ğŸ“Š Transaction Management:**
    6. **Transaction Best Practices:**
       - âœ… **Explicit Transactions**: Use `BEGIN`, `COMMIT`, and `ROLLBACK` explicitly
       - âœ… **Short Transactions**: Keep transactions as short as possible
       - âœ… **Error Handling**: Implement proper rollback on errors
       - âœ… **Isolation Levels**: Understand and use appropriate isolation levels
       - âœ… **Deadlock Prevention**: Order operations consistently to avoid deadlocks
       - âœ… **Monitoring**: Track transaction duration and failure rates
    
    7. **Transaction Patterns:**
       - âœ… **Read-Only Transactions**: Use for consistent reads across multiple queries
       - âœ… **Write Transactions**: Group related modifications in single transactions
       - âœ… **Nested Transactions**: Use savepoints for complex transaction logic
       - âœ… **Distributed Transactions**: Consider 2PC for multi-database operations
    
    
    **ğŸ“ˆ Error Handling & Resilience:**
    8. **Error Handling Strategies:**
        - âœ… **Connection Errors**: Handle connection failures with retry logic
        - âœ… **Query Errors**: Handle syntax and constraint violation errors
        - âœ… **Transaction Errors**: Implement proper rollback and retry logic
        - âœ… **Deadlock Handling**: Implement exponential backoff for deadlock retries
        - âœ… **Logging**: Log all database errors with context and stack traces
    
    9. **Retry Logic:**
        - âœ… Implement exponential backoff with jitter for transient errors
        - âœ… Set maximum retry attempts to prevent infinite loops
        - âœ… Use circuit breaker patterns for persistent failures
        - âœ… Monitor retry patterns and adjust strategies accordingly
    
    **ğŸ” Query Clarity & Maintainability:**
    10. **Query Readability:**
        - âœ… **Aliases**: Use meaningful table and column aliases
        - âœ… **Formatting**: Format SQL queries for readability
        - âœ… **Comments**: Add comments for complex queries
        - âœ… **Consistency**: Use consistent naming conventions
        - âœ… **Modularity**: Break complex queries into smaller, readable parts
    
    11. **Query Optimization:**
        - âœ… **LIMIT**: Always use LIMIT for potentially large result sets
        - âœ… **OFFSET**: Use cursor-based pagination instead of OFFSET for large datasets
        - âœ… **Window Functions**: Use window functions for ranking and aggregation
        - âœ… **CTEs**: Use Common Table Expressions for complex queries
        - âœ… **Materialized Views**: Consider materialized views for expensive aggregations
    
    
    **ğŸ“Š Observability & Monitoring:**
    12. **Metrics & Monitoring:**
        - âœ… Track query latency and throughput
        - âœ… Monitor connection pool utilization
        - âœ… Track slow query patterns and execution plans
        - âœ… Monitor index usage and performance impact
        - âœ… Track transaction success rates and durations
        - âœ… Implement health checks for database availability
    
    13. **Logging & Tracing:**
        - âœ… Log slow queries and performance issues
        - âœ… Include correlation IDs for request tracing
        - âœ… Log transaction conflicts and retry attempts
        - âœ… Use structured logging with consistent field names
        - âœ… Log query execution plans for optimization
    
    **ğŸš¨ Common Anti-Patterns to Flag:**
    - âŒ String concatenation in SQL queries (SQL injection risk)
    - âŒ Missing parameterized queries or prepared statements
    - âŒ N+1 query patterns in loops
    - âŒ Missing indexes on frequently queried columns
    - âŒ Using `SELECT *` instead of specific columns
    - âŒ Missing transaction boundaries for related operations
    - âŒ No connection pooling or timeout configuration
    - âŒ Hardcoded database credentials
    - âŒ No error handling for database failures
    - âŒ Missing LIMIT clauses on potentially large result sets
    
    **ğŸ” Review Focus Areas:**
    - Verify SQL injection prevention and parameterized queries
    - Check for N+1 query patterns and performance issues
    - Ensure proper connection management and pooling
    - Validate transaction design and error handling
    - Review index usage and query optimization
    - Check for monitoring and observability implementation
    - Identify opportunities for Prometheus metrics
    
    **ğŸ“Š Prometheus Metrics Opportunities:**
    - ğŸ” **Automatically suggest metrics when seeing:**
      - Database queries â†’ `postgres_queries_total{operation, table, status}`
      - Query latency â†’ `postgres_query_duration_seconds{operation, table}`
      - Connection usage â†’ `postgres_connections_active{state}`
      - Transaction metrics â†’ `postgres_transactions_total{type, status}`
      - Index operations â†’ `postgres_index_operations_total{operation, index_name}`
      - Error handling â†’ `postgres_errors_total{type, operation}`
      - Connection pool â†’ `postgres_connection_pool_size{state}`
