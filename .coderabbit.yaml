# .coderabbit.base.yaml - Base configuration template


version: 1
reviews:

  # =============================================================================
  # AUTOMATIC LABELING CONFIGURATION
  # =============================================================================
  # 
  # When enabled, CodeRabbit will automatically suggest and apply labels
  # based on the content and scope of pull requests. This helps with:
  # - PR categorization and filtering
  # - Automated workflows and notifications
  # - Release note generation
  # - Team communication and prioritization
  auto_apply_labels: true

  # Label instructions define when and how to apply specific labels
  # Each label has clear criteria to help CodeRabbit make accurate suggestions
  labeling_instructions:
    # --- Core Change Types ---
    # These labels cover the fundamental types of changes in software development
    
    - label: "feature"
      instructions: |
        Apply when the pull request introduces new functionality or a significant new capability.
        Look for new user stories, API endpoints, or major additions to existing features.
        
        EXAMPLES:
        - New API endpoints or methods
        - New user interface components
        - New business logic or algorithms
        - New configuration options
        - New integration points with external services

    - label: "bugfix"
      instructions: |
        Apply when the pull request primarily fixes an identified bug, defect, or incorrect behavior.
        Often addresses a specific issue or error report.
        
        EXAMPLES:
        - Fixing incorrect calculations or logic
        - Resolving error handling issues
        - Correcting UI display problems
        - Fixing performance bottlenecks
        - Resolving integration failures

    - label: "refactor"
      instructions: |
        Apply when the pull request restructures or cleans up existing code without altering its external behavior.
        Focus on code readability, maintainability, or internal design improvements.
        
        EXAMPLES:
        - Renaming variables or functions for clarity
        - Extracting common code into shared functions
        - Improving code organization and structure
        - Updating code style to match guidelines
        - Optimizing internal algorithms without changing behavior

    - label: "documentation"
      instructions: |
        Apply when the pull request primarily modifies documentation.
        Look for changes in `.md`, `.rst`, `docs/`, `README.md`, or similar documentation files.
        
        EXAMPLES:
        - Updating README files
        - Adding inline code comments
        - Creating or updating API documentation
        - Writing user guides or tutorials
        - Updating configuration examples

    - label: "chore"
      instructions: |
        Apply for routine maintenance, dependency updates, build system changes, or minor configuration adjustments.
        These are non-functional changes that don't directly add features or fix bugs in the application logic.
        
        EXAMPLES:
        - Updating package dependencies
        - Modifying build scripts or CI/CD configs
        - Updating development environment setup
        - Code formatting or linting fixes
        - Repository maintenance tasks

    - label: "tests"
      instructions: |
        Apply when the pull request primarily adds new tests, updates existing tests, or refactors test code.
        Look for changes in `test/`, `__tests__/`, `*.test.ts`, or other dedicated test directories/files.
        
        EXAMPLES:
        - Adding unit tests for new functionality
        - Improving test coverage for existing code
        - Refactoring test structure or organization
        - Adding integration or end-to-end tests
        - Updating test data or fixtures
    
    - label: "security"
      instructions: |
        Apply when the pull request addresses security vulnerabilities, implements security features,
        or modifies authentication/authorization logic. Look for changes in security-related code,
        encryption, input validation, or access control mechanisms.
        
        EXAMPLES:
        - Adding input validation and sanitization
        - Implementing authentication mechanisms
        - Adding authorization checks
        - Updating encryption or hashing
        - Fixing security vulnerabilities
        - Adding security headers or policies

    - label: "performance"
      instructions: |
        Apply when the pull request optimizes performance, reduces latency, improves throughput,
        or addresses performance bottlenecks. Look for changes in caching, algorithm improvements, or
        resource optimization changes.
        
        EXAMPLES:
        - Adding caching mechanisms
        - Optimizing database queries
        - Improving algorithm efficiency
        - Reducing memory usage
        - Optimizing network requests
        - Adding performance monitoring

    - label: "dependencies"
      instructions: |
        Apply when the pull request updates, adds, or removes dependencies, packages,
        or external libraries. Look for changes in package.json, requirements.txt,
        go.mod, or similar dependency files.
        
        EXAMPLES:
        - Updating package versions
        - Adding new dependencies
        - Removing unused dependencies
        - Updating lock files
        - Changing dependency sources

  # =============================================================================
  # PATH-SPECIFIC INSTRUCTIONS
  # =============================================================================
  # 
  # This section will be automatically populated by the merge tool
  # from individual technology-specific configuration files in configs/*/
  # 
  # Each technology (HTTP, Redis, Kafka, etc.) has its own path_instructions.yaml
  # file that gets merged here during the build process.
  path_instructions:
    - path: "**/{http,client,api,network}*/**"
      instructions: |
        **Comprehensive HTTP Client Code Review Checklist:**

        **üîß Performance & Resource Management:**
        1. **Client Reuse & Connection Pooling:** 
           - ‚úÖ Reuse HTTP client instances (don't create new clients per request)
           - ‚úÖ Configure connection pool settings: `MaxIdleConns`, `MaxConnsPerHost`, `MaxIdleConnsPerHost`
           - ‚úÖ Set appropriate `IdleConnTimeout` to prevent stale connections
           - ‚úÖ Use `DisableKeepAlives: false` for better performance (unless specifically needed)

        2. **Timeouts (CRITICAL):**
           - ‚úÖ Set `ConnectTimeout` for TCP connection establishment (e.g., 5-30s)
           - ‚úÖ Set `RequestTimeout` for total request duration (e.g., 10-60s)
           - ‚úÖ Set `ReadTimeout` for response body reading
           - ‚úÖ Set `WriteTimeout` for request body writing
           - ‚ö†Ô∏è Never use infinite timeouts - this can cause resource leaks

        3. **Resource Cleanup:**
           - ‚úÖ Always close response body: `defer resp.Body.Close()` (Go) or equivalent
           - ‚úÖ Handle response body even if you don't need it (read to EOF or close)
           - ‚úÖ Use `io.Copy(io.Discard, resp.Body)` for discarding unwanted responses

        4. **Request Headers & Authentication:**
           - ‚úÖ Set appropriate `User-Agent` header
           - ‚úÖ Use secure authentication methods (Bearer tokens, API keys)
           - ‚úÖ Don't log sensitive headers (Authorization, Cookie, etc.)
           - ‚úÖ Set `Content-Type` and `Accept` headers appropriately

        **üìä Error Handling & Resilience:**
        5. **Status Code Handling:**
           - ‚úÖ Handle all status codes: 2xx (success), 4xx (client error), 5xx (server error)
           - ‚úÖ Check `resp.StatusCode` before processing response body
           - ‚úÖ Provide meaningful error messages for different status codes
           - ‚úÖ Handle redirects appropriately (3xx status codes)

        6. **Retry Logic:**
           - ‚úÖ Implement exponential backoff with jitter for transient errors
           - ‚úÖ Only retry idempotent operations (GET, PUT, DELETE, not POST)
           - ‚úÖ Set maximum retry attempts to prevent infinite loops
           - ‚úÖ Use appropriate retry conditions (5xx errors, network timeouts)

        7. **Error Handling:**
           - ‚úÖ Use language-appropriate error handling patterns
           - ‚úÖ Wrap errors with context: `fmt.Errorf("failed to make request: %w", err)`
           - ‚úÖ Handle network errors separately from HTTP errors
           - ‚úÖ Provide actionable error messages for debugging

        **üìà Observability & Monitoring:**
        8. **Logging & Tracing:**
           - ‚úÖ Log request details (method, URL, headers) at DEBUG level
           - ‚úÖ Log response status and timing at INFO level
           - ‚úÖ Log errors with full context (request details, response status)
           - ‚úÖ Use structured logging with consistent field names
           - ‚úÖ Implement request/response correlation IDs for tracing

        9. **Metrics & Monitoring:**
          - ‚úÖ Track request duration, status codes, and error rates
          - ‚úÖ Monitor connection pool utilization
          - ‚úÖ Alert on high error rates or timeout percentages
          - ‚úÖ Use histetheus metrics for comprehensive monitoring

          **üìä Prometheus Metrics Opportunities:**
          - üîç **Automatically suggest metrics when seeing:**
            - HTTP requests ‚Üí `http_requests_total{method, endpoint, status_code}`
            - Response times ‚Üí `http_request_duration_seconds{method, endpoint}`
            - Error handling ‚Üí `http_errors_total{type, endpoint, status_code}`
            - Timeout handling ‚Üí `http_timeouts_total{type, endpoint}`
            - Connection pools ‚Üí `http_connection_pool_size{state}`
            - Retry logic ‚Üí `http_retries_total{endpoint, reason}`
            - Circuit breakers ‚Üí `http_circuit_breaker_state{endpoint}`

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Creating new HTTP client per request
        - ‚ùå Missing timeout configurations
        - ‚ùå Not closing response bodies
        - ‚ùå Ignoring HTTP status codes
        - ‚ùå Hardcoded URLs or credentials
        - ‚ùå No error handling for network failures
        - ‚ùå Infinite retry loops
        - ‚ùå Logging sensitive information

        **üîç Review Focus Areas:**
        - Look for proper client configuration and reuse
        - Verify timeout settings are reasonable and not infinite
        - Check response body handling and cleanup
        - Ensure proper error handling and logging
        - Validate security practices (HTTPS, auth, headers)
        - Review retry logic for correctness and safety
        - Identify opportunities for Prometheus metrics
        - Suggest appropriate monitoring and alerting

    - path: "**/*{http*,client*,api*,network*}*"
      instructions: |
        **Comprehensive HTTP Client Code Review Checklist:**

        **üîß Performance & Resource Management:**
        1. **Client Reuse & Connection Pooling:** 
           - ‚úÖ Reuse HTTP client instances (don't create new clients per request)
           - ‚úÖ Configure connection pool settings: `MaxIdleConns`, `MaxConnsPerHost`, `MaxIdleConnsPerHost`
           - ‚úÖ Set appropriate `IdleConnTimeout` to prevent stale connections
           - ‚úÖ Use `DisableKeepAlives: false` for better performance (unless specifically needed)

        2. **Timeouts (CRITICAL):**
           - ‚úÖ Set `ConnectTimeout` for TCP connection establishment (e.g., 5-30s)
           - ‚úÖ Set `RequestTimeout` for total request duration (e.g., 10-60s)
           - ‚úÖ Set `ReadTimeout` for response body reading
           - ‚úÖ Set `WriteTimeout` for request body writing
           - ‚ö†Ô∏è Never use infinite timeouts - this can cause resource leaks

        3. **Resource Cleanup:**
           - ‚úÖ Always close response body: `defer resp.Body.Close()` (Go) or equivalent
           - ‚úÖ Handle response body even if you don't need it (read to EOF or close)
           - ‚úÖ Use `io.Copy(io.Discard, resp.Body)` for discarding unwanted responses

        4. **Request Headers & Authentication:**
           - ‚úÖ Set appropriate `User-Agent` header
           - ‚úÖ Use secure authentication methods (Bearer tokens, API keys)
           - ‚úÖ Don't log sensitive headers (Authorization, Cookie, etc.)
           - ‚úÖ Set `Content-Type` and `Accept` headers appropriately

        **üìä Error Handling & Resilience:**
        5. **Status Code Handling:**
           - ‚úÖ Handle all status codes: 2xx (success), 4xx (client error), 5xx (server error)
           - ‚úÖ Check `resp.StatusCode` before processing response body
           - ‚úÖ Provide meaningful error messages for different status codes
           - ‚úÖ Handle redirects appropriately (3xx status codes)

        6. **Retry Logic:**
           - ‚úÖ Implement exponential backoff with jitter for transient errors
           - ‚úÖ Only retry idempotent operations (GET, PUT, DELETE, not POST)
           - ‚úÖ Set maximum retry attempts to prevent infinite loops
           - ‚úÖ Use appropriate retry conditions (5xx errors, network timeouts)

        7. **Error Handling:**
           - ‚úÖ Use language-appropriate error handling patterns
           - ‚úÖ Wrap errors with context: `fmt.Errorf("failed to make request: %w", err)`
           - ‚úÖ Handle network errors separately from HTTP errors
           - ‚úÖ Provide actionable error messages for debugging

        **üìà Observability & Monitoring:**
        8. **Logging & Tracing:**
           - ‚úÖ Log request details (method, URL, headers) at DEBUG level
           - ‚úÖ Log response status and timing at INFO level
           - ‚úÖ Log errors with full context (request details, response status)
           - ‚úÖ Use structured logging with consistent field names
           - ‚úÖ Implement request/response correlation IDs for tracing

        9. **Metrics & Monitoring:**
          - ‚úÖ Track request duration, status codes, and error rates
          - ‚úÖ Monitor connection pool utilization
          - ‚úÖ Alert on high error rates or timeout percentages
          - ‚úÖ Use histetheus metrics for comprehensive monitoring

          **üìä Prometheus Metrics Opportunities:**
          - üîç **Automatically suggest metrics when seeing:**
            - HTTP requests ‚Üí `http_requests_total{method, endpoint, status_code}`
            - Response times ‚Üí `http_request_duration_seconds{method, endpoint}`
            - Error handling ‚Üí `http_errors_total{type, endpoint, status_code}`
            - Timeout handling ‚Üí `http_timeouts_total{type, endpoint}`
            - Connection pools ‚Üí `http_connection_pool_size{state}`
            - Retry logic ‚Üí `http_retries_total{endpoint, reason}`
            - Circuit breakers ‚Üí `http_circuit_breaker_state{endpoint}`

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Creating new HTTP client per request
        - ‚ùå Missing timeout configurations
        - ‚ùå Not closing response bodies
        - ‚ùå Ignoring HTTP status codes
        - ‚ùå Hardcoded URLs or credentials
        - ‚ùå No error handling for network failures
        - ‚ùå Infinite retry loops
        - ‚ùå Logging sensitive information

        **üîç Review Focus Areas:**
        - Look for proper client configuration and reuse
        - Verify timeout settings are reasonable and not infinite
        - Check response body handling and cleanup
        - Ensure proper error handling and logging
        - Validate security practices (HTTPS, auth, headers)
        - Review retry logic for correctness and safety
        - Identify opportunities for Prometheus metrics
        - Suggest appropriate monitoring and alerting

    - path: "**/{kafka,producer,consumer,broker,topic,stream}*/**"
      instructions: |
        **Comprehensive Kafka Code Review Checklist:**

        **üîß Client Lifecycle & Resource Management:**
        1. **Singleton Client Pattern:**
           - ‚úÖ Reuse Kafka client instances (Producer, Consumer) throughout application lifecycle
           - ‚úÖ Avoid creating new clients per request/operation
           - ‚úÖ Use dependency injection or singleton patterns for client management
           - ‚ö†Ô∏è Never create clients inside loops or per-message functions

        2. **Connection Management:**
           - ‚úÖ Configure appropriate connection pool settings
           - ‚úÖ Set reasonable connection timeouts and retry policies
           - ‚úÖ Handle connection failures gracefully with exponential backoff
           - ‚úÖ Implement proper client cleanup and shutdown procedures

        **üì§ Producer Configuration & Best Practices:**
        3. **Performance Tuning:**
           - ‚úÖ Configure `MaxBatchBytes` for optimal batch sizes (e.g., 16KB-1MB)
           - ‚úÖ Set `MaxBufferedRecords` to control memory usage
           - ‚úÖ Use `ProducerLinger` to balance latency vs throughput
           - ‚úÖ Configure `RecordRetries` for failed message handling (typically 3-5)
           - ‚úÖ Set `ProduceRequestTimeout` to prevent indefinite hangs

        4. **Reliability & Consistency:**
           - ‚úÖ Enable idempotent producers (`enable.idempotence=true`) to prevent duplicates
           - ‚úÖ Configure `RequiredAcks` based on durability needs:
             - `LeaderAck` for high throughput, lower durability
             - `AllISRAcks` for highest durability, lower throughput
           - ‚úÖ Implement proper error handling for different failure scenarios

        5. **Batching & Compression:**
           - ‚úÖ Enable compression (Gzip, Snappy, LZ4, Zstd) for network efficiency
           - ‚úÖ Tune `batch.size` and `linger.ms` for optimal compression ratios
           - ‚úÖ Ensure `max.request.size` accommodates your batch sizes

        **üì• Consumer Configuration & Best Practices:**
        6. **Performance & Efficiency:**
           - ‚úÖ Configure `FetchMinBytes` and `FetchMaxBytes` for optimal throughput
           - ‚úÖ Set `MaxConcurrentFetches` based on available resources
           - ‚úÖ Use appropriate `SessionTimeout` and `RebalanceTimeout` values
           - ‚úÖ Configure `HeartbeatInterval` for stable consumer group membership

        7. **Offset Management:**
           - ‚úÖ Use `enable.auto.commit=false` for manual control when needed
           - ‚úÖ Handle offset commit failures gracefully
           - ‚úÖ Implement offset reset strategies for consumer group scenarios
           - ‚úÖ Monitor consumer lag and implement alerting

        8. **Consumer Group Management:**
           - ‚úÖ Ensure consumers are part of a consumer group
           - ‚úÖ Handle rebalancing events properly
           - ‚úÖ Implement graceful shutdown procedures
           - ‚úÖ Monitor consumer group health and stability

        **üõ°Ô∏è Security & Best Practices:**
        9. **Authentication & Authorization:**
           - ‚úÖ Use secure credential management (not hardcoded)

        10. **Data Security:**
            - ‚úÖ Use encryption for sensitive data in transit
            - ‚úÖ Implement proper key management for encrypted topics
            - ‚úÖ Audit access patterns and implement monitoring
            - ‚úÖ Follow principle of least privilege for topic access

        **üìä Error Handling & Resilience:**
        11. **Error Classification & Handling:**
            - ‚úÖ Distinguish between transient and permanent errors
            - ‚úÖ Implement retry logic with exponential backoff for transient errors
            - ‚úÖ Handle permanent errors gracefully (log, alert, circuit break)
            - ‚úÖ Implement dead letter queues for failed messages
            - ‚úÖ Monitor error rates and implement alerting

        12. **Circuit Breaker Patterns:**
            - ‚úÖ Implement circuit breakers for broker failures
            - ‚úÖ Monitor circuit breaker state and metrics
            - ‚úÖ Implement fallback mechanisms when possible

        **üìà Observability & Monitoring:**
        13. **Metrics & Monitoring:**
            - ‚úÖ Track producer/consumer throughput and latency
            - ‚úÖ Monitor consumer lag and offset commit success rates
            - ‚úÖ Track error rates and failure patterns
            - ‚úÖ Monitor connection pool utilization and health
            - ‚úÖ Implement health checks for Kafka clients

        14. **Logging & Tracing:**
            - ‚úÖ Log important operations (produce/consume, errors, rebalances)
            - ‚úÖ Include correlation IDs for request tracing
            - ‚úÖ Log configuration changes and client lifecycle events
            - ‚úÖ Use structured logging with consistent field names

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Creating new Kafka clients per operation
        - ‚ùå Missing error handling for network failures
        - ‚ùå No retry logic for transient errors
        - ‚ùå Missing timeout configurations
        - ‚ùå Hardcoded broker addresses or credentials
        - ‚ùå No monitoring or metrics implementation
        - ‚ùå Missing consumer group configuration
        - ‚ùå No offset commit error handling
        - ‚ùå Disabled idempotence without justification
        - ‚ùå No compression enabled for producers

        **üîç Review Focus Areas:**
        - Verify client lifecycle management and reuse patterns
        - Check producer/consumer configuration for optimal settings
        - Ensure proper error handling and retry logic
        - Validate security configurations and authentication
        - Review offset management and consumer group handling
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Kafka producers ‚Üí `kafka_producer_messages_total{topic, status}`
          - Kafka consumers ‚Üí `kafka_consumer_messages_total{topic, partition}`
          - Message processing ‚Üí `kafka_message_duration_seconds{topic, operation}`
          - Error handling ‚Üí `kafka_errors_total{type, topic, operation}`
          - Consumer lag ‚Üí `kafka_consumer_lag{topic, partition, group}`
          - Connection health ‚Üí `kafka_connection_status{broker, state}`
          - Offset commits ‚Üí `kafka_offset_commits_total{topic, group, status}`

    - path: "**/*{kafka*,producer*,consumer*,broker*,topic*,stream*}*"
      instructions: |
        **Comprehensive Kafka Code Review Checklist:**

        **üîß Client Lifecycle & Resource Management:**
        1. **Singleton Client Pattern:**
           - ‚úÖ Reuse Kafka client instances (Producer, Consumer) throughout application lifecycle
           - ‚úÖ Avoid creating new clients per request/operation
           - ‚úÖ Use dependency injection or singleton patterns for client management
           - ‚ö†Ô∏è Never create clients inside loops or per-message functions

        2. **Connection Management:**
           - ‚úÖ Configure appropriate connection pool settings
           - ‚úÖ Set reasonable connection timeouts and retry policies
           - ‚úÖ Handle connection failures gracefully with exponential backoff
           - ‚úÖ Implement proper client cleanup and shutdown procedures

        **üì§ Producer Configuration & Best Practices:**
        3. **Performance Tuning:**
           - ‚úÖ Configure `MaxBatchBytes` for optimal batch sizes (e.g., 16KB-1MB)
           - ‚úÖ Set `MaxBufferedRecords` to control memory usage
           - ‚úÖ Use `ProducerLinger` to balance latency vs throughput
           - ‚úÖ Configure `RecordRetries` for failed message handling (typically 3-5)
           - ‚úÖ Set `ProduceRequestTimeout` to prevent indefinite hangs

        4. **Reliability & Consistency:**
           - ‚úÖ Enable idempotent producers (`enable.idempotence=true`) to prevent duplicates
           - ‚úÖ Configure `RequiredAcks` based on durability needs:
             - `LeaderAck` for high throughput, lower durability
             - `AllISRAcks` for highest durability, lower throughput
           - ‚úÖ Implement proper error handling for different failure scenarios

        5. **Batching & Compression:**
           - ‚úÖ Enable compression (Gzip, Snappy, LZ4, Zstd) for network efficiency
           - ‚úÖ Tune `batch.size` and `linger.ms` for optimal compression ratios
           - ‚úÖ Ensure `max.request.size` accommodates your batch sizes

        **üì• Consumer Configuration & Best Practices:**
        6. **Performance & Efficiency:**
           - ‚úÖ Configure `FetchMinBytes` and `FetchMaxBytes` for optimal throughput
           - ‚úÖ Set `MaxConcurrentFetches` based on available resources
           - ‚úÖ Use appropriate `SessionTimeout` and `RebalanceTimeout` values
           - ‚úÖ Configure `HeartbeatInterval` for stable consumer group membership

        7. **Offset Management:**
           - ‚úÖ Use `enable.auto.commit=false` for manual control when needed
           - ‚úÖ Handle offset commit failures gracefully
           - ‚úÖ Implement offset reset strategies for consumer group scenarios
           - ‚úÖ Monitor consumer lag and implement alerting

        8. **Consumer Group Management:**
           - ‚úÖ Ensure consumers are part of a consumer group
           - ‚úÖ Handle rebalancing events properly
           - ‚úÖ Implement graceful shutdown procedures
           - ‚úÖ Monitor consumer group health and stability

        **üõ°Ô∏è Security & Best Practices:**
        9. **Authentication & Authorization:**
           - ‚úÖ Use secure credential management (not hardcoded)

        10. **Data Security:**
            - ‚úÖ Use encryption for sensitive data in transit
            - ‚úÖ Implement proper key management for encrypted topics
            - ‚úÖ Audit access patterns and implement monitoring
            - ‚úÖ Follow principle of least privilege for topic access

        **üìä Error Handling & Resilience:**
        11. **Error Classification & Handling:**
            - ‚úÖ Distinguish between transient and permanent errors
            - ‚úÖ Implement retry logic with exponential backoff for transient errors
            - ‚úÖ Handle permanent errors gracefully (log, alert, circuit break)
            - ‚úÖ Implement dead letter queues for failed messages
            - ‚úÖ Monitor error rates and implement alerting

        12. **Circuit Breaker Patterns:**
            - ‚úÖ Implement circuit breakers for broker failures
            - ‚úÖ Monitor circuit breaker state and metrics
            - ‚úÖ Implement fallback mechanisms when possible

        **üìà Observability & Monitoring:**
        13. **Metrics & Monitoring:**
            - ‚úÖ Track producer/consumer throughput and latency
            - ‚úÖ Monitor consumer lag and offset commit success rates
            - ‚úÖ Track error rates and failure patterns
            - ‚úÖ Monitor connection pool utilization and health
            - ‚úÖ Implement health checks for Kafka clients

        14. **Logging & Tracing:**
            - ‚úÖ Log important operations (produce/consume, errors, rebalances)
            - ‚úÖ Include correlation IDs for request tracing
            - ‚úÖ Log configuration changes and client lifecycle events
            - ‚úÖ Use structured logging with consistent field names

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Creating new Kafka clients per operation
        - ‚ùå Missing error handling for network failures
        - ‚ùå No retry logic for transient errors
        - ‚ùå Missing timeout configurations
        - ‚ùå Hardcoded broker addresses or credentials
        - ‚ùå No monitoring or metrics implementation
        - ‚ùå Missing consumer group configuration
        - ‚ùå No offset commit error handling
        - ‚ùå Disabled idempotence without justification
        - ‚ùå No compression enabled for producers

        **üîç Review Focus Areas:**
        - Verify client lifecycle management and reuse patterns
        - Check producer/consumer configuration for optimal settings
        - Ensure proper error handling and retry logic
        - Validate security configurations and authentication
        - Review offset management and consumer group handling
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Kafka producers ‚Üí `kafka_producer_messages_total{topic, status}`
          - Kafka consumers ‚Üí `kafka_consumer_messages_total{topic, partition}`
          - Message processing ‚Üí `kafka_message_duration_seconds{topic, operation}`
          - Error handling ‚Üí `kafka_errors_total{type, topic, operation}`
          - Consumer lag ‚Üí `kafka_consumer_lag{topic, partition, group}`
          - Connection health ‚Üí `kafka_connection_status{broker, state}`
          - Offset commits ‚Üí `kafka_offset_commits_total{topic, group, status}`

    - path: "**/{redis,df,dragonfly,cache,queue}*/**"
      instructions: |
        **Comprehensive Redis Code Review Checklist:**

        **üîë Key Management & Naming:**
        1. **Key Naming Conventions:**
           - ‚úÖ Use clear, hierarchical key names (e.g., `user:123:profile`, `order:456:items`)
           - ‚úÖ Keep keys concise to save memory space
           - ‚úÖ Use consistent naming patterns across your application
           - ‚úÖ Avoid excessively long key names (>100 characters)
           - ‚úÖ Use colons (`:`) for hierarchical separation, not underscores or dashes

        2. **Key Expiration & TTL:**
           - ‚úÖ Always set appropriate TTL for transient/cache data
           - ‚úÖ Use `EXPIRE` or `PEXPIRE` for automatic cleanup
           - ‚ö†Ô∏è Never set TTL to 0 (indefinite) for cache data

        **üöÄ Performance & Scalability:**
        3. **Avoiding Unbounded Operations:**
           - ‚úÖ **Never use without limits**: `HGETALL`, `LRANGE`, `SMEMBERS`, `ZRANGE`
           - ‚úÖ **Always check size first**: Use `HLEN`, `LLEN`, `SCARD`, `ZCARD`
           - ‚úÖ **Use iterative commands**: `HSCAN`, `SSCAN`, `ZSCAN`, `LSCAN`
           - ‚úÖ **Set reasonable limits**: `LRANGE key 0 99` instead of `LRANGE key 0 -1`
           - ‚úÖ **Implement pagination**: Use `SCAN` with cursor-based iteration

        4. **Blocking Commands (Production Forbidden):**
           - ‚ùå **Never use in production**: `KEYS`, `FLUSHALL`, `FLUSHDB`
           - ‚úÖ **Use alternatives**: `SCAN` for key discovery, selective deletion
           - ‚úÖ **Implement safely**: Use `DEL` with specific keys, not pattern deletion
           - ‚úÖ **Monitor usage**: Alert on any blocking command execution

        5. **Pipelining & Batching:**
           - ‚úÖ Use pipelining for multiple related operations
           - ‚úÖ Batch commands to reduce network round-trips
           - ‚úÖ Use `MULTI`/`EXEC` for atomic operations when needed

        **üîå Connection & Resource Management:**
        6. **Connection Pooling:**
           - ‚úÖ Configure appropriate pool size based on application load
           - ‚úÖ Set `PoolSize`, `MinIdleConns`, `MaxIdleConns`
           - ‚úÖ Configure `PoolTimeout` for connection acquisition
           - ‚úÖ Monitor pool utilization and connection health
           - ‚úÖ Implement connection health checks

        7. **Timeout Configuration:**
           - ‚úÖ Set `ReadTimeout` for response reading operations
           - ‚úÖ Set `WriteTimeout` for request writing operations
           - ‚úÖ Set `DialTimeout` for connection establishment
           - ‚úÖ Use reasonable timeout values (typically 1-30 seconds)
           - ‚ö†Ô∏è Never use infinite timeouts

        8. **Resource Cleanup:**
            - ‚úÖ Properly close Redis connections
            - ‚úÖ Implement connection cleanup in application shutdown
            - ‚úÖ Handle connection failures gracefully
            - ‚úÖ Monitor for connection leaks

        **üìà Error Handling & Resilience:**
        9. **Error Handling Strategies:**
            - ‚úÖ Handle Redis connection failures gracefully
            - ‚úÖ Implement retry logic with exponential backoff
            - ‚úÖ Use circuit breaker patterns for Redis failures
            - ‚úÖ Implement fallback strategies when Redis is unavailable
            - ‚úÖ Log Redis errors with appropriate context

        10. **Fallback Mechanisms:**
            - ‚úÖ Implement local caching when Redis is down
            - ‚úÖ Use database as fallback for critical data
            - ‚úÖ Graceful degradation of non-critical features
            - ‚úÖ Monitor fallback usage and Redis health

        **üíæ Data Management & Optimization:**
        11. **Compression & Serialization:**
            - ‚úÖ Use compression for large values (gzip, zstd, lz4)
            - ‚úÖ Choose appropriate serialization format (JSON, MessagePack, Protocol Buffers)
            - ‚úÖ Monitor compression ratios and performance impact
            - ‚úÖ Balance compression vs CPU overhead

        **üìä Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - ‚úÖ Track Redis operation latency and throughput
            - ‚úÖ Monitor connection pool utilization
            - ‚úÖ Track error rates and failure patterns
            - ‚úÖ Monitor memory usage and key expiration
            - ‚úÖ Implement health checks for Redis availability

        13. **Logging & Tracing:**
            - ‚úÖ Log Redis operations with appropriate detail
            - ‚úÖ Include correlation IDs for request tracing
            - ‚úÖ Log slow queries and performance issues
            - ‚úÖ Use structured logging with consistent field names


        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Make sure that the redis client is not created for each request
        - ‚ùå Using `KEYS` command in production code
        - ‚ùå Unbounded `HGETALL`, `LRANGE`, `SMEMBERS` without size checks
        - ‚ùå Missing TTL for cache data
        - ‚ùå No connection pooling or timeout configuration
        - ‚ùå Hardcoded Redis credentials or connection strings
        - ‚ùå No error handling for Redis failures
        - ‚ùå Missing fallback mechanisms for Redis unavailability
        - ‚ùå No monitoring or health checks implemented
        - ‚ùå Using `FLUSHALL`/`FLUSHDB` in application code
        - ‚ùå No compression for large values

        **üîç Review Focus Areas:**
        - Verify key naming conventions and TTL usage
        - Check for unbounded operations and blocking commands
        - Ensure proper connection pooling and timeout configuration
        - Validate security settings and authentication
        - Review error handling and fallback strategies
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Redis operations ‚Üí `redis_operations_total{operation, status}`
          - Operation latency ‚Üí `redis_operation_duration_seconds{operation}`
          - Connection usage ‚Üí `redis_connections_active{state}`
          - Memory usage ‚Üí `redis_memory_bytes{type}`
          - Key operations ‚Üí `redis_keys_total{operation, data_type}`
          - Error handling ‚Üí `redis_errors_total{type, operation}`
          - Cache hits/misses ‚Üí `redis_cache_hits_total{key_pattern}`

    - path: "**/*{redis*,df*,dragonfly*,cache*,queue*}*"
      instructions: |
        **Comprehensive Redis Code Review Checklist:**

        **üîë Key Management & Naming:**
        1. **Key Naming Conventions:**
           - ‚úÖ Use clear, hierarchical key names (e.g., `user:123:profile`, `order:456:items`)
           - ‚úÖ Keep keys concise to save memory space
           - ‚úÖ Use consistent naming patterns across your application
           - ‚úÖ Avoid excessively long key names (>100 characters)
           - ‚úÖ Use colons (`:`) for hierarchical separation, not underscores or dashes

        2. **Key Expiration & TTL:**
           - ‚úÖ Always set appropriate TTL for transient/cache data
           - ‚úÖ Use `EXPIRE` or `PEXPIRE` for automatic cleanup
           - ‚ö†Ô∏è Never set TTL to 0 (indefinite) for cache data

        **üöÄ Performance & Scalability:**
        3. **Avoiding Unbounded Operations:**
           - ‚úÖ **Never use without limits**: `HGETALL`, `LRANGE`, `SMEMBERS`, `ZRANGE`
           - ‚úÖ **Always check size first**: Use `HLEN`, `LLEN`, `SCARD`, `ZCARD`
           - ‚úÖ **Use iterative commands**: `HSCAN`, `SSCAN`, `ZSCAN`, `LSCAN`
           - ‚úÖ **Set reasonable limits**: `LRANGE key 0 99` instead of `LRANGE key 0 -1`
           - ‚úÖ **Implement pagination**: Use `SCAN` with cursor-based iteration

        4. **Blocking Commands (Production Forbidden):**
           - ‚ùå **Never use in production**: `KEYS`, `FLUSHALL`, `FLUSHDB`
           - ‚úÖ **Use alternatives**: `SCAN` for key discovery, selective deletion
           - ‚úÖ **Implement safely**: Use `DEL` with specific keys, not pattern deletion
           - ‚úÖ **Monitor usage**: Alert on any blocking command execution

        5. **Pipelining & Batching:**
           - ‚úÖ Use pipelining for multiple related operations
           - ‚úÖ Batch commands to reduce network round-trips
           - ‚úÖ Use `MULTI`/`EXEC` for atomic operations when needed

        **üîå Connection & Resource Management:**
        6. **Connection Pooling:**
           - ‚úÖ Configure appropriate pool size based on application load
           - ‚úÖ Set `PoolSize`, `MinIdleConns`, `MaxIdleConns`
           - ‚úÖ Configure `PoolTimeout` for connection acquisition
           - ‚úÖ Monitor pool utilization and connection health
           - ‚úÖ Implement connection health checks

        7. **Timeout Configuration:**
           - ‚úÖ Set `ReadTimeout` for response reading operations
           - ‚úÖ Set `WriteTimeout` for request writing operations
           - ‚úÖ Set `DialTimeout` for connection establishment
           - ‚úÖ Use reasonable timeout values (typically 1-30 seconds)
           - ‚ö†Ô∏è Never use infinite timeouts

        8. **Resource Cleanup:**
            - ‚úÖ Properly close Redis connections
            - ‚úÖ Implement connection cleanup in application shutdown
            - ‚úÖ Handle connection failures gracefully
            - ‚úÖ Monitor for connection leaks

        **üìà Error Handling & Resilience:**
        9. **Error Handling Strategies:**
            - ‚úÖ Handle Redis connection failures gracefully
            - ‚úÖ Implement retry logic with exponential backoff
            - ‚úÖ Use circuit breaker patterns for Redis failures
            - ‚úÖ Implement fallback strategies when Redis is unavailable
            - ‚úÖ Log Redis errors with appropriate context

        10. **Fallback Mechanisms:**
            - ‚úÖ Implement local caching when Redis is down
            - ‚úÖ Use database as fallback for critical data
            - ‚úÖ Graceful degradation of non-critical features
            - ‚úÖ Monitor fallback usage and Redis health

        **üíæ Data Management & Optimization:**
        11. **Compression & Serialization:**
            - ‚úÖ Use compression for large values (gzip, zstd, lz4)
            - ‚úÖ Choose appropriate serialization format (JSON, MessagePack, Protocol Buffers)
            - ‚úÖ Monitor compression ratios and performance impact
            - ‚úÖ Balance compression vs CPU overhead

        **üìä Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - ‚úÖ Track Redis operation latency and throughput
            - ‚úÖ Monitor connection pool utilization
            - ‚úÖ Track error rates and failure patterns
            - ‚úÖ Monitor memory usage and key expiration
            - ‚úÖ Implement health checks for Redis availability

        13. **Logging & Tracing:**
            - ‚úÖ Log Redis operations with appropriate detail
            - ‚úÖ Include correlation IDs for request tracing
            - ‚úÖ Log slow queries and performance issues
            - ‚úÖ Use structured logging with consistent field names


        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Make sure that the redis client is not created for each request
        - ‚ùå Using `KEYS` command in production code
        - ‚ùå Unbounded `HGETALL`, `LRANGE`, `SMEMBERS` without size checks
        - ‚ùå Missing TTL for cache data
        - ‚ùå No connection pooling or timeout configuration
        - ‚ùå Hardcoded Redis credentials or connection strings
        - ‚ùå No error handling for Redis failures
        - ‚ùå Missing fallback mechanisms for Redis unavailability
        - ‚ùå No monitoring or health checks implemented
        - ‚ùå Using `FLUSHALL`/`FLUSHDB` in application code
        - ‚ùå No compression for large values

        **üîç Review Focus Areas:**
        - Verify key naming conventions and TTL usage
        - Check for unbounded operations and blocking commands
        - Ensure proper connection pooling and timeout configuration
        - Validate security settings and authentication
        - Review error handling and fallback strategies
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Redis operations ‚Üí `redis_operations_total{operation, status}`
          - Operation latency ‚Üí `redis_operation_duration_seconds{operation}`
          - Connection usage ‚Üí `redis_connections_active{state}`
          - Memory usage ‚Üí `redis_memory_bytes{type}`
          - Key operations ‚Üí `redis_keys_total{operation, data_type}`
          - Error handling ‚Üí `redis_errors_total{type, operation}`
          - Cache hits/misses ‚Üí `redis_cache_hits_total{key_pattern}`

    - path: "**/{scylladb,scylla}*/**"
      instructions: |
        **Comprehensive ScyllaDB Code Review Checklist:**

        **üîß Client Lifecycle & Resource Management:**
        1. **Connection Management:**
           - ‚úÖ Configure appropriate connection pool size and timeouts
           - ‚úÖ Implement graceful connection closing and cleanup
           - ‚úÖ Handle connection failures with exponential backoff
           - ‚ö†Ô∏è Never create new client connections per request

        2. **Session Management:**
           - ‚úÖ Reuse session instances throughout application lifecycle
           - ‚úÖ Configure session-level timeouts and retry policies
           - ‚úÖ Implement proper session cleanup in application shutdown
           - ‚úÖ Monitor session health and connection status

        **üìä Query Performance & Optimization:**
        3. **Prepared Statements:**
           - ‚úÖ Use prepared statements for frequently executed queries
           - ‚úÖ Cache prepared statements at application level
           - ‚úÖ Avoid dynamic query construction to prevent CQL injection
           - ‚úÖ Monitor prepared statement cache hit rates

        4. **Query Timeouts:**
           - ‚úÖ Set explicit timeouts for all queries (typically 5-30 seconds)
           - ‚úÖ Configure different timeouts for reads vs writes
           - ‚úÖ Implement query cancellation for long-running operations
           - ‚ö†Ô∏è Never use infinite timeouts - can cause resource exhaustion

        5. **Consistency Levels:**
           - ‚úÖ Explicitly set appropriate consistency levels for all operations
           - ‚úÖ **Read Consistency**: `ONE` (fast), `LOCAL_QUORUM` (balanced), `QUORUM` (strong)
           - ‚úÖ **Write Consistency**: `ONE` (fast), `LOCAL_QUORUM` (balanced), `QUORUM` (strong)
           - ‚úÖ Understand trade-offs: higher consistency = lower availability + higher latency
           - ‚úÖ Document consistency level choices with business justification

        **üöÄ Performance & Scalability:**
        6. **BYPASS CACHE Optimization:**
           - ‚úÖ Use `BYPASS CACHE` for large range queries that aren't latency-sensitive

        7. **Batch Operations:**
           - ‚úÖ Use batch statements for multiple related operations
           - ‚úÖ Keep batch sizes reasonable (typically 10-100 operations)

        **üõ°Ô∏è Security & Best Practices:**
        8. **Authentication & Authorization:**
           - ‚úÖ Use proper authentication (username/password, certificates)
           - ‚úÖ Use secure credential management (environment variables, not hardcoded)

        9. **Query Security:**
            - ‚úÖ Use parameterized queries to prevent CQL injection

        **üìà Error Handling & Resilience:**
        10. **Retry Strategies:**
            - ‚úÖ Implement intelligent retry logic with exponential backoff
            - ‚úÖ Use jitter in retry delays to prevent thundering herd
            - ‚ö†Ô∏è **Critical**: Avoid aggressive retries during database surges
            - ‚úÖ Monitor retry patterns and adjust strategies accordingly

        11. **Error Classification:**
            - ‚úÖ Handle `UnavailableException` for temporary failures
            - ‚úÖ Handle `ReadTimeoutException` and `WriteTimeoutException`
            - ‚úÖ Handle `ConsistencyException` for consistency level violations
            - ‚úÖ Implement circuit breaker patterns for persistent failures


        **üìä Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - ‚úÖ Track query latency and throughput
            - ‚úÖ Monitor connection pool utilization

        13. **Logging & Tracing:**
            - ‚úÖ Log slow queries and performance issues
            - ‚úÖ Include correlation IDs for request tracing
            - ‚úÖ Log consistency level violations and retries
            - ‚úÖ Use structured logging with consistent field names

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Creating new ScyllaDB clients per request
        - ‚ùå Missing query timeouts or infinite timeouts
        - ‚ùå No retry logic for transient failures
        - ‚ùå Missing consistency level configuration
        - ‚ùå Hardcoded credentials or connection strings
        - ‚ùå No monitoring or metrics implementation
        - ‚ùå No prepared statement usage for repeated queries
        - ‚ùå Aggressive retries during database surges
        - ‚ùå Missing error handling for different exception types

        **üîç Review Focus Areas:**
        - Verify client lifecycle management and connection pooling
        - Check query timeout configurations and consistency levels
        - Ensure proper error handling and retry strategies
        - Validate security configurations and authentication
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - ScyllaDB queries ‚Üí `scylla_queries_total{operation, consistency, status}`
          - Query latency ‚Üí `scylla_query_duration_seconds{operation, consistency}`
          - Connection usage ‚Üí `scylla_connections_active{state}`
          - Consistency violations ‚Üí `scylla_consistency_violations_total{operation}`
          - Retry attempts ‚Üí `scylla_retries_total{operation, reason}`
          - Cache operations ‚Üí `scylla_cache_operations_total{operation, status}`

    - path: "**/*{scylladb*,scylla*}*"
      instructions: |
        **Comprehensive ScyllaDB Code Review Checklist:**

        **üîß Client Lifecycle & Resource Management:**
        1. **Connection Management:**
           - ‚úÖ Configure appropriate connection pool size and timeouts
           - ‚úÖ Implement graceful connection closing and cleanup
           - ‚úÖ Handle connection failures with exponential backoff
           - ‚ö†Ô∏è Never create new client connections per request

        2. **Session Management:**
           - ‚úÖ Reuse session instances throughout application lifecycle
           - ‚úÖ Configure session-level timeouts and retry policies
           - ‚úÖ Implement proper session cleanup in application shutdown
           - ‚úÖ Monitor session health and connection status

        **üìä Query Performance & Optimization:**
        3. **Prepared Statements:**
           - ‚úÖ Use prepared statements for frequently executed queries
           - ‚úÖ Cache prepared statements at application level
           - ‚úÖ Avoid dynamic query construction to prevent CQL injection
           - ‚úÖ Monitor prepared statement cache hit rates

        4. **Query Timeouts:**
           - ‚úÖ Set explicit timeouts for all queries (typically 5-30 seconds)
           - ‚úÖ Configure different timeouts for reads vs writes
           - ‚úÖ Implement query cancellation for long-running operations
           - ‚ö†Ô∏è Never use infinite timeouts - can cause resource exhaustion

        5. **Consistency Levels:**
           - ‚úÖ Explicitly set appropriate consistency levels for all operations
           - ‚úÖ **Read Consistency**: `ONE` (fast), `LOCAL_QUORUM` (balanced), `QUORUM` (strong)
           - ‚úÖ **Write Consistency**: `ONE` (fast), `LOCAL_QUORUM` (balanced), `QUORUM` (strong)
           - ‚úÖ Understand trade-offs: higher consistency = lower availability + higher latency
           - ‚úÖ Document consistency level choices with business justification

        **üöÄ Performance & Scalability:**
        6. **BYPASS CACHE Optimization:**
           - ‚úÖ Use `BYPASS CACHE` for large range queries that aren't latency-sensitive

        7. **Batch Operations:**
           - ‚úÖ Use batch statements for multiple related operations
           - ‚úÖ Keep batch sizes reasonable (typically 10-100 operations)

        **üõ°Ô∏è Security & Best Practices:**
        8. **Authentication & Authorization:**
           - ‚úÖ Use proper authentication (username/password, certificates)
           - ‚úÖ Use secure credential management (environment variables, not hardcoded)

        9. **Query Security:**
            - ‚úÖ Use parameterized queries to prevent CQL injection

        **üìà Error Handling & Resilience:**
        10. **Retry Strategies:**
            - ‚úÖ Implement intelligent retry logic with exponential backoff
            - ‚úÖ Use jitter in retry delays to prevent thundering herd
            - ‚ö†Ô∏è **Critical**: Avoid aggressive retries during database surges
            - ‚úÖ Monitor retry patterns and adjust strategies accordingly

        11. **Error Classification:**
            - ‚úÖ Handle `UnavailableException` for temporary failures
            - ‚úÖ Handle `ReadTimeoutException` and `WriteTimeoutException`
            - ‚úÖ Handle `ConsistencyException` for consistency level violations
            - ‚úÖ Implement circuit breaker patterns for persistent failures


        **üìä Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - ‚úÖ Track query latency and throughput
            - ‚úÖ Monitor connection pool utilization

        13. **Logging & Tracing:**
            - ‚úÖ Log slow queries and performance issues
            - ‚úÖ Include correlation IDs for request tracing
            - ‚úÖ Log consistency level violations and retries
            - ‚úÖ Use structured logging with consistent field names

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Creating new ScyllaDB clients per request
        - ‚ùå Missing query timeouts or infinite timeouts
        - ‚ùå No retry logic for transient failures
        - ‚ùå Missing consistency level configuration
        - ‚ùå Hardcoded credentials or connection strings
        - ‚ùå No monitoring or metrics implementation
        - ‚ùå No prepared statement usage for repeated queries
        - ‚ùå Aggressive retries during database surges
        - ‚ùå Missing error handling for different exception types

        **üîç Review Focus Areas:**
        - Verify client lifecycle management and connection pooling
        - Check query timeout configurations and consistency levels
        - Ensure proper error handling and retry strategies
        - Validate security configurations and authentication
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - ScyllaDB queries ‚Üí `scylla_queries_total{operation, consistency, status}`
          - Query latency ‚Üí `scylla_query_duration_seconds{operation, consistency}`
          - Connection usage ‚Üí `scylla_connections_active{state}`
          - Consistency violations ‚Üí `scylla_consistency_violations_total{operation}`
          - Retry attempts ‚Üí `scylla_retries_total{operation, reason}`
          - Cache operations ‚Üí `scylla_cache_operations_total{operation, status}`

    - path: "**/{spanner}*/**"
      instructions: |
        **Comprehensive Google Spanner Code Review Checklist:**

        **üîß Client Lifecycle & Resource Management:**
        1. **Connection Management:**
           - ‚úÖ Configure appropriate connection pool size and timeouts
           - ‚úÖ Implement graceful client cleanup and shutdown
           - ‚úÖ Handle connection failures with exponential backoff
           - ‚ö†Ô∏è Never create new Spanner clients per request

        2. **Session Management:**
           - ‚úÖ Reuse session instances throughout application lifecycle
           - ‚úÖ Configure session-level timeouts and retry policies
           - ‚úÖ Implement proper session cleanup in application shutdown

        **üìä Transaction Management:**
        3. **Transaction Types & Usage:**
           - ‚úÖ Use `ReadOnlyTransaction` for read-only operations
           - ‚úÖ Use `ReadWriteTransaction` for data modifications

        4. **Transaction Best Practices:**
           - ‚úÖ **Error Handling**: Implement proper rollback and retry logic
           - ‚úÖ **Monitoring**: Track transaction duration and failure rates

        **üöÄ Performance & Query Optimization:**
        5. **Query Timeouts:**
           - ‚úÖ Set explicit timeouts for all Spanner queries (typically 5-60 seconds). This is during client initialization
           - ‚úÖ Configure different timeouts for reads vs writes
           - ‚úÖ Implement query cancellation for long-running operations
           - ‚úÖ Use `StatementTimeout` for individual query timeouts
           - ‚ö†Ô∏è Never use infinite timeouts - can cause resource exhaustion


        6. **Query Priority Management:**
           - ‚úÖ Set appropriate query priorities: `HIGH`, `MEDIUM`, or `LOW`
           - ‚úÖ **HIGH Priority**: Critical user-facing queries, real-time operations
           - ‚úÖ **MEDIUM Priority**: Standard business operations, batch processing
           - ‚úÖ **LOW Priority**: Background jobs, analytics, non-critical operations
           - ‚úÖ Balance priority levels to manage resource contention effectively

        7. **FORCE_INDEX Usage:**
           - ‚úÖ Use `FORCE_INDEX` when you need Spanner to use a specific index
           - ‚úÖ **Use Cases**: Query optimization, performance testing, index validation
           - ‚úÖ **Caution**: Only use when you're confident about index choice
           - ‚úÖ **Monitoring**: Track query performance with forced vs automatic index selection
           - ‚úÖ **Documentation**: Document why specific indexes are forced

        8. **Query Security:**
            - ‚úÖ Use parameterized queries to prevent SQL injection
            - ‚úÖ Use prepared statements for repeated queries

        **üìà Error Handling & Resilience:**
        9. **Error Classification & Handling:**
            - ‚úÖ Handle `AbortedException` for transaction conflicts
            - ‚úÖ Handle `DeadlineExceededException` for timeout scenarios
            - ‚úÖ Handle `ResourceExhaustedException` for quota limits
            - ‚úÖ Handle `FailedPreconditionException` for invalid operations

        10. **Retry Strategies:**
            - ‚úÖ Implement intelligent retry logic with exponential backoff
            - ‚úÖ Use jitter in retry delays to prevent thundering herd
            - ‚úÖ Distinguish between retryable and non-retryable errors
            - ‚úÖ Implement backoff strategies for different error types
            - ‚úÖ Monitor retry patterns and adjust strategies accordingly

        **üìä Observability & Monitoring:**
        11. **Metrics & Monitoring:**
            - ‚úÖ Track query latency and throughput
            - ‚úÖ Monitor transaction success rates and durations
            - ‚úÖ Monitor connection pool utilization


        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Creating new Spanner clients per request
        - ‚ùå Missing query timeouts or infinite timeouts
        - ‚ùå Long-running transactions (>10 seconds)
        - ‚ùå No retry logic for transient failures
        - ‚ùå Missing query priority configuration
        - ‚ùå Hardcoded credentials or connection strings
        - ‚ùå No monitoring or metrics implementation
        - ‚ùå Missing error handling for different exception types
        - ‚ùå No transaction conflict resolution
        - ‚ùå **SELECT ***: Always specify required columns explicitly

        **üîç Review Focus Areas:**
        - Verify client lifecycle management and connection pooling
        - Check transaction design and duration optimization
        - Ensure proper error handling and retry strategies
        - Validate security configurations and authentication
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Spanner queries ‚Üí `spanner_queries_total{operation, priority, status}`
          - Query latency ‚Üí `spanner_query_duration_seconds{operation, priority}`
          - Transaction metrics ‚Üí `spanner_transactions_total{type, status}`
          - Connection usage ‚Üí `spanner_connections_active{state}`
          - Index operations ‚Üí `spanner_index_operations_total{operation, index_name}`
          - Error handling ‚Üí `spanner_errors_total{type, operation}`
          - Retry attempts ‚Üí `spanner_retries_total{operation, reason}`

    - path: "**/*{spanner*}*"
      instructions: |
        **Comprehensive Google Spanner Code Review Checklist:**

        **üîß Client Lifecycle & Resource Management:**
        1. **Connection Management:**
           - ‚úÖ Configure appropriate connection pool size and timeouts
           - ‚úÖ Implement graceful client cleanup and shutdown
           - ‚úÖ Handle connection failures with exponential backoff
           - ‚ö†Ô∏è Never create new Spanner clients per request

        2. **Session Management:**
           - ‚úÖ Reuse session instances throughout application lifecycle
           - ‚úÖ Configure session-level timeouts and retry policies
           - ‚úÖ Implement proper session cleanup in application shutdown

        **üìä Transaction Management:**
        3. **Transaction Types & Usage:**
           - ‚úÖ Use `ReadOnlyTransaction` for read-only operations
           - ‚úÖ Use `ReadWriteTransaction` for data modifications

        4. **Transaction Best Practices:**
           - ‚úÖ **Error Handling**: Implement proper rollback and retry logic
           - ‚úÖ **Monitoring**: Track transaction duration and failure rates

        **üöÄ Performance & Query Optimization:**
        5. **Query Timeouts:**
           - ‚úÖ Set explicit timeouts for all Spanner queries (typically 5-60 seconds). This is during client initialization
           - ‚úÖ Configure different timeouts for reads vs writes
           - ‚úÖ Implement query cancellation for long-running operations
           - ‚úÖ Use `StatementTimeout` for individual query timeouts
           - ‚ö†Ô∏è Never use infinite timeouts - can cause resource exhaustion


        6. **Query Priority Management:**
           - ‚úÖ Set appropriate query priorities: `HIGH`, `MEDIUM`, or `LOW`
           - ‚úÖ **HIGH Priority**: Critical user-facing queries, real-time operations
           - ‚úÖ **MEDIUM Priority**: Standard business operations, batch processing
           - ‚úÖ **LOW Priority**: Background jobs, analytics, non-critical operations
           - ‚úÖ Balance priority levels to manage resource contention effectively

        7. **FORCE_INDEX Usage:**
           - ‚úÖ Use `FORCE_INDEX` when you need Spanner to use a specific index
           - ‚úÖ **Use Cases**: Query optimization, performance testing, index validation
           - ‚úÖ **Caution**: Only use when you're confident about index choice
           - ‚úÖ **Monitoring**: Track query performance with forced vs automatic index selection
           - ‚úÖ **Documentation**: Document why specific indexes are forced

        8. **Query Security:**
            - ‚úÖ Use parameterized queries to prevent SQL injection
            - ‚úÖ Use prepared statements for repeated queries

        **üìà Error Handling & Resilience:**
        9. **Error Classification & Handling:**
            - ‚úÖ Handle `AbortedException` for transaction conflicts
            - ‚úÖ Handle `DeadlineExceededException` for timeout scenarios
            - ‚úÖ Handle `ResourceExhaustedException` for quota limits
            - ‚úÖ Handle `FailedPreconditionException` for invalid operations

        10. **Retry Strategies:**
            - ‚úÖ Implement intelligent retry logic with exponential backoff
            - ‚úÖ Use jitter in retry delays to prevent thundering herd
            - ‚úÖ Distinguish between retryable and non-retryable errors
            - ‚úÖ Implement backoff strategies for different error types
            - ‚úÖ Monitor retry patterns and adjust strategies accordingly

        **üìä Observability & Monitoring:**
        11. **Metrics & Monitoring:**
            - ‚úÖ Track query latency and throughput
            - ‚úÖ Monitor transaction success rates and durations
            - ‚úÖ Monitor connection pool utilization


        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Creating new Spanner clients per request
        - ‚ùå Missing query timeouts or infinite timeouts
        - ‚ùå Long-running transactions (>10 seconds)
        - ‚ùå No retry logic for transient failures
        - ‚ùå Missing query priority configuration
        - ‚ùå Hardcoded credentials or connection strings
        - ‚ùå No monitoring or metrics implementation
        - ‚ùå Missing error handling for different exception types
        - ‚ùå No transaction conflict resolution
        - ‚ùå **SELECT ***: Always specify required columns explicitly

        **üîç Review Focus Areas:**
        - Verify client lifecycle management and connection pooling
        - Check transaction design and duration optimization
        - Ensure proper error handling and retry strategies
        - Validate security configurations and authentication
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Spanner queries ‚Üí `spanner_queries_total{operation, priority, status}`
          - Query latency ‚Üí `spanner_query_duration_seconds{operation, priority}`
          - Transaction metrics ‚Üí `spanner_transactions_total{type, status}`
          - Connection usage ‚Üí `spanner_connections_active{state}`
          - Index operations ‚Üí `spanner_index_operations_total{operation, index_name}`
          - Error handling ‚Üí `spanner_errors_total{type, operation}`
          - Retry attempts ‚Üí `spanner_retries_total{operation, reason}`

    - path: "**/{postgres,cloudsql,db,database,sql,psql}*/**"
      instructions: |
        **Comprehensive PostgreSQL/CloudSQL Code Review Checklist:**

        **üõ°Ô∏è Security & Injection Prevention:**
        1. **SQL Injection Prevention:**
           - ‚úÖ **Always use parameterized queries** to prevent SQL injection
           - ‚úÖ Use prepared statements for repeated queries
           - ‚úÖ Never concatenate user input directly into SQL strings
           - ‚úÖ Use ORM query builders when possible for additional safety
           - ‚ö†Ô∏è **Critical**: Flag any string concatenation in SQL queries

        **üöÄ Performance & Query Optimization:**
        2. **Query Performance Analysis:**
           - ‚úÖ **N+1 Query Detection**: Look for loops that execute database queries
           - ‚úÖ **Batching**: Use `IN` clauses or batch operations instead of individual queries

        3. **Performance Anti-Patterns:**
           - ‚ùå **FULL SCAN**: Avoid table scans on large tables
           - ‚ùå **CARTESIAN JOIN**: Never use cross joins without explicit WHERE conditions
           - ‚ùå **SELECT ***: Always specify required columns explicitly
           - ‚ùå **Subqueries in SELECT**: Use JOINs when possible
           - ‚ùå **Functions on indexed columns**: Avoid applying functions to indexed columns


        **üîå Connection & Resource Management:**
        4. **Connection Management:**
           - ‚úÖ Use connection pooling (PgBouncer, application-level pools)
           - ‚úÖ Configure appropriate pool size based on application load
           - ‚úÖ Set connection timeouts and idle connection limits
           - ‚úÖ Implement proper connection cleanup and error handling
           - ‚úÖ Monitor connection pool utilization and health

        5. **Resource Cleanup:**
           - ‚úÖ Always close database connections after use
           - ‚úÖ Use try-with-resources or defer statements for cleanup
           - ‚úÖ Implement proper error handling with connection cleanup
           - ‚úÖ Monitor for connection leaks and resource exhaustion
           - ‚úÖ Handle connection failures gracefully with retry logic

        **üìä Transaction Management:**
        6. **Transaction Best Practices:**
           - ‚úÖ **Explicit Transactions**: Use `BEGIN`, `COMMIT`, and `ROLLBACK` explicitly
           - ‚úÖ **Short Transactions**: Keep transactions as short as possible
           - ‚úÖ **Error Handling**: Implement proper rollback on errors
           - ‚úÖ **Isolation Levels**: Understand and use appropriate isolation levels
           - ‚úÖ **Deadlock Prevention**: Order operations consistently to avoid deadlocks
           - ‚úÖ **Monitoring**: Track transaction duration and failure rates

        7. **Transaction Patterns:**
           - ‚úÖ **Read-Only Transactions**: Use for consistent reads across multiple queries
           - ‚úÖ **Write Transactions**: Group related modifications in single transactions
           - ‚úÖ **Nested Transactions**: Use savepoints for complex transaction logic
           - ‚úÖ **Distributed Transactions**: Consider 2PC for multi-database operations


        **üìà Error Handling & Resilience:**
        8. **Error Handling Strategies:**
            - ‚úÖ **Connection Errors**: Handle connection failures with retry logic
            - ‚úÖ **Query Errors**: Handle syntax and constraint violation errors
            - ‚úÖ **Transaction Errors**: Implement proper rollback and retry logic
            - ‚úÖ **Deadlock Handling**: Implement exponential backoff for deadlock retries
            - ‚úÖ **Logging**: Log all database errors with context and stack traces

        9. **Retry Logic:**
            - ‚úÖ Implement exponential backoff with jitter for transient errors
            - ‚úÖ Set maximum retry attempts to prevent infinite loops
            - ‚úÖ Use circuit breaker patterns for persistent failures
            - ‚úÖ Monitor retry patterns and adjust strategies accordingly

        **üîç Query Clarity & Maintainability:**
        10. **Query Readability:**
            - ‚úÖ **Aliases**: Use meaningful table and column aliases
            - ‚úÖ **Formatting**: Format SQL queries for readability
            - ‚úÖ **Comments**: Add comments for complex queries
            - ‚úÖ **Consistency**: Use consistent naming conventions
            - ‚úÖ **Modularity**: Break complex queries into smaller, readable parts

        11. **Query Optimization:**
            - ‚úÖ **LIMIT**: Always use LIMIT for potentially large result sets
            - ‚úÖ **OFFSET**: Use cursor-based pagination instead of OFFSET for large datasets
            - ‚úÖ **Window Functions**: Use window functions for ranking and aggregation
            - ‚úÖ **CTEs**: Use Common Table Expressions for complex queries
            - ‚úÖ **Materialized Views**: Consider materialized views for expensive aggregations


        **üìä Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - ‚úÖ Track query latency and throughput
            - ‚úÖ Monitor connection pool utilization
            - ‚úÖ Track slow query patterns and execution plans
            - ‚úÖ Monitor index usage and performance impact
            - ‚úÖ Track transaction success rates and durations
            - ‚úÖ Implement health checks for database availability

        13. **Logging & Tracing:**
            - ‚úÖ Log slow queries and performance issues
            - ‚úÖ Include correlation IDs for request tracing
            - ‚úÖ Log transaction conflicts and retry attempts
            - ‚úÖ Use structured logging with consistent field names
            - ‚úÖ Log query execution plans for optimization

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå String concatenation in SQL queries (SQL injection risk)
        - ‚ùå Missing parameterized queries or prepared statements
        - ‚ùå N+1 query patterns in loops
        - ‚ùå Missing indexes on frequently queried columns
        - ‚ùå Using `SELECT *` instead of specific columns
        - ‚ùå Missing transaction boundaries for related operations
        - ‚ùå No connection pooling or timeout configuration
        - ‚ùå Hardcoded database credentials
        - ‚ùå No error handling for database failures
        - ‚ùå Missing LIMIT clauses on potentially large result sets

        **üîç Review Focus Areas:**
        - Verify SQL injection prevention and parameterized queries
        - Check for N+1 query patterns and performance issues
        - Ensure proper connection management and pooling
        - Validate transaction design and error handling
        - Review index usage and query optimization
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Database queries ‚Üí `postgres_queries_total{operation, table, status}`
          - Query latency ‚Üí `postgres_query_duration_seconds{operation, table}`
          - Connection usage ‚Üí `postgres_connections_active{state}`
          - Transaction metrics ‚Üí `postgres_transactions_total{type, status}`
          - Index operations ‚Üí `postgres_index_operations_total{operation, index_name}`
          - Error handling ‚Üí `postgres_errors_total{type, operation}`
          - Connection pool ‚Üí `postgres_connection_pool_size{state}`

    - path: "**/*{postgres*,cloudsql*,db*,database*,sql*,psql*}*"
      instructions: |
        **Comprehensive PostgreSQL/CloudSQL Code Review Checklist:**

        **üõ°Ô∏è Security & Injection Prevention:**
        1. **SQL Injection Prevention:**
           - ‚úÖ **Always use parameterized queries** to prevent SQL injection
           - ‚úÖ Use prepared statements for repeated queries
           - ‚úÖ Never concatenate user input directly into SQL strings
           - ‚úÖ Use ORM query builders when possible for additional safety
           - ‚ö†Ô∏è **Critical**: Flag any string concatenation in SQL queries

        **üöÄ Performance & Query Optimization:**
        2. **Query Performance Analysis:**
           - ‚úÖ **N+1 Query Detection**: Look for loops that execute database queries
           - ‚úÖ **Batching**: Use `IN` clauses or batch operations instead of individual queries

        3. **Performance Anti-Patterns:**
           - ‚ùå **FULL SCAN**: Avoid table scans on large tables
           - ‚ùå **CARTESIAN JOIN**: Never use cross joins without explicit WHERE conditions
           - ‚ùå **SELECT ***: Always specify required columns explicitly
           - ‚ùå **Subqueries in SELECT**: Use JOINs when possible
           - ‚ùå **Functions on indexed columns**: Avoid applying functions to indexed columns


        **üîå Connection & Resource Management:**
        4. **Connection Management:**
           - ‚úÖ Use connection pooling (PgBouncer, application-level pools)
           - ‚úÖ Configure appropriate pool size based on application load
           - ‚úÖ Set connection timeouts and idle connection limits
           - ‚úÖ Implement proper connection cleanup and error handling
           - ‚úÖ Monitor connection pool utilization and health

        5. **Resource Cleanup:**
           - ‚úÖ Always close database connections after use
           - ‚úÖ Use try-with-resources or defer statements for cleanup
           - ‚úÖ Implement proper error handling with connection cleanup
           - ‚úÖ Monitor for connection leaks and resource exhaustion
           - ‚úÖ Handle connection failures gracefully with retry logic

        **üìä Transaction Management:**
        6. **Transaction Best Practices:**
           - ‚úÖ **Explicit Transactions**: Use `BEGIN`, `COMMIT`, and `ROLLBACK` explicitly
           - ‚úÖ **Short Transactions**: Keep transactions as short as possible
           - ‚úÖ **Error Handling**: Implement proper rollback on errors
           - ‚úÖ **Isolation Levels**: Understand and use appropriate isolation levels
           - ‚úÖ **Deadlock Prevention**: Order operations consistently to avoid deadlocks
           - ‚úÖ **Monitoring**: Track transaction duration and failure rates

        7. **Transaction Patterns:**
           - ‚úÖ **Read-Only Transactions**: Use for consistent reads across multiple queries
           - ‚úÖ **Write Transactions**: Group related modifications in single transactions
           - ‚úÖ **Nested Transactions**: Use savepoints for complex transaction logic
           - ‚úÖ **Distributed Transactions**: Consider 2PC for multi-database operations


        **üìà Error Handling & Resilience:**
        8. **Error Handling Strategies:**
            - ‚úÖ **Connection Errors**: Handle connection failures with retry logic
            - ‚úÖ **Query Errors**: Handle syntax and constraint violation errors
            - ‚úÖ **Transaction Errors**: Implement proper rollback and retry logic
            - ‚úÖ **Deadlock Handling**: Implement exponential backoff for deadlock retries
            - ‚úÖ **Logging**: Log all database errors with context and stack traces

        9. **Retry Logic:**
            - ‚úÖ Implement exponential backoff with jitter for transient errors
            - ‚úÖ Set maximum retry attempts to prevent infinite loops
            - ‚úÖ Use circuit breaker patterns for persistent failures
            - ‚úÖ Monitor retry patterns and adjust strategies accordingly

        **üîç Query Clarity & Maintainability:**
        10. **Query Readability:**
            - ‚úÖ **Aliases**: Use meaningful table and column aliases
            - ‚úÖ **Formatting**: Format SQL queries for readability
            - ‚úÖ **Comments**: Add comments for complex queries
            - ‚úÖ **Consistency**: Use consistent naming conventions
            - ‚úÖ **Modularity**: Break complex queries into smaller, readable parts

        11. **Query Optimization:**
            - ‚úÖ **LIMIT**: Always use LIMIT for potentially large result sets
            - ‚úÖ **OFFSET**: Use cursor-based pagination instead of OFFSET for large datasets
            - ‚úÖ **Window Functions**: Use window functions for ranking and aggregation
            - ‚úÖ **CTEs**: Use Common Table Expressions for complex queries
            - ‚úÖ **Materialized Views**: Consider materialized views for expensive aggregations


        **üìä Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - ‚úÖ Track query latency and throughput
            - ‚úÖ Monitor connection pool utilization
            - ‚úÖ Track slow query patterns and execution plans
            - ‚úÖ Monitor index usage and performance impact
            - ‚úÖ Track transaction success rates and durations
            - ‚úÖ Implement health checks for database availability

        13. **Logging & Tracing:**
            - ‚úÖ Log slow queries and performance issues
            - ‚úÖ Include correlation IDs for request tracing
            - ‚úÖ Log transaction conflicts and retry attempts
            - ‚úÖ Use structured logging with consistent field names
            - ‚úÖ Log query execution plans for optimization

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå String concatenation in SQL queries (SQL injection risk)
        - ‚ùå Missing parameterized queries or prepared statements
        - ‚ùå N+1 query patterns in loops
        - ‚ùå Missing indexes on frequently queried columns
        - ‚ùå Using `SELECT *` instead of specific columns
        - ‚ùå Missing transaction boundaries for related operations
        - ‚ùå No connection pooling or timeout configuration
        - ‚ùå Hardcoded database credentials
        - ‚ùå No error handling for database failures
        - ‚ùå Missing LIMIT clauses on potentially large result sets

        **üîç Review Focus Areas:**
        - Verify SQL injection prevention and parameterized queries
        - Check for N+1 query patterns and performance issues
        - Ensure proper connection management and pooling
        - Validate transaction design and error handling
        - Review index usage and query optimization
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Database queries ‚Üí `postgres_queries_total{operation, table, status}`
          - Query latency ‚Üí `postgres_query_duration_seconds{operation, table}`
          - Connection usage ‚Üí `postgres_connections_active{state}`
          - Transaction metrics ‚Üí `postgres_transactions_total{type, status}`
          - Index operations ‚Üí `postgres_index_operations_total{operation, index_name}`
          - Error handling ‚Üí `postgres_errors_total{type, operation}`
          - Connection pool ‚Üí `postgres_connection_pool_size{state}`

    - path: "**/{temporal,worker,workflow,task,activit}*/**"
      instructions: |
        **Comprehensive Temporal Code Review Checklist:**

        **üîí Workflow Determinism (Critical):**
        1. **Deterministic Operations:**
           - ‚úÖ **No System Time**: Never use `System.currentTimeMillis()`, `new Date()`, or similar
           - ‚úÖ **No Random Numbers**: Never use `Math.random()`, `Random.nextInt()`, or similar
           - ‚úÖ **No UUID Generation**: Never use `UUID.randomUUID()` or similar
           - ‚úÖ **Use Temporal APIs**: Use `workflow.now()`, `workflow.randomUUID()`, `workflow.sideEffect()`
           - ‚ö†Ô∏è **Critical**: Any non-deterministic operation will cause workflow replay failures

        2. **Side Effect Isolation:**
           - ‚úÖ **No Direct I/O**: Never make database calls, network requests, or file system access
           - ‚úÖ **No External Services**: Never call external APIs or services directly
           - ‚úÖ **Delegate to Activities**: All side effects must be in Activities, not Workflows
           - ‚úÖ **Pure Functions**: Workflows should be pure, deterministic functions

        3. **State Management:**
           - ‚úÖ **No Global State**: Never use static variables or global mutable state
           - ‚úÖ **No Concurrent Access**: Avoid concurrent data structures unless managed by Temporal
           - ‚úÖ **Immutable Data**: Use immutable data structures when possible
           - ‚úÖ **Workflow State**: Store state in workflow variables, not external storage

        **üìã Activity Design & Implementation:**
        4. **Activity Idempotency:**
           - ‚úÖ **Always Idempotent**: Design activities to be safely retryable
           - ‚úÖ **Idempotency Keys**: Use unique keys for operations with side effects
           - ‚úÖ **State Checks**: Check current state before performing operations
           - ‚úÖ **Compensation Logic**: Implement rollback mechanisms for failed operations
           - ‚úÖ **No Side Effects**: Activities should be safe to execute multiple times

        5. **Activity Error Handling:**
           - ‚úÖ **Retry Policies**: Configure appropriate retry policies for different error types
           - ‚úÖ **Error Classification**: Distinguish between retryable and non-retryable errors
           - ‚úÖ **Timeout Configuration**: Set appropriate `StartToCloseTimeout` values
           - ‚úÖ **Heartbeating**: Implement heartbeating for long-running activities
           - ‚úÖ **Circuit Breakers**: Use circuit breakers for external service calls

        6. **Activity Timeouts:**
           - ‚úÖ **StartToCloseTimeout**: Maximum time for activity execution
           - ‚úÖ **ScheduleToStartTimeout**: Maximum time to wait for worker assignment
           - ‚úÖ **HeartbeatTimeout**: Maximum time between heartbeats
           - ‚úÖ **ScheduleToCloseTimeout**: Maximum time from scheduling to completion
           - ‚úÖ **Retry Policies**: Configure retry delays and maximum attempts

        **‚öôÔ∏è Worker Configuration & Management:**
        7. **Worker Concurrency:**
           - ‚úÖ **Activity Concurrency**: Set `MaxConcurrentActivityExecutionSize` appropriately
           - ‚úÖ **Workflow Concurrency**: Set `MaxConcurrentWorkflowTaskExecutionSize`
           - ‚úÖ **Task Polling**: Configure `MaxConcurrentActivityTaskPollers`
           - ‚úÖ **Workflow Polling**: Configure `MaxConcurrentWorkflowTaskPollers`
           - ‚úÖ **Resource Limits**: Balance concurrency with available system resources

        8. **Worker Lifecycle:**
           - ‚úÖ **Graceful Shutdown**: Implement proper shutdown procedures
           - ‚úÖ **Health Checks**: Monitor worker health and availability
           - ‚úÖ **Connection Management**: Handle Temporal service connection failures
           - ‚úÖ **Task Processing**: Ensure tasks are processed efficiently
           - ‚úÖ **Error Recovery**: Implement worker-level error recovery mechanisms

        **üîÑ Workflow Orchestration:**
        9. **Workflow Structure:**
           - ‚úÖ **Single Responsibility**: Each workflow should have one clear purpose
           - ‚úÖ **Granular Activities**: Break complex operations into smaller activities
           - ‚úÖ **Error Propagation**: Properly handle and propagate errors from activities
           - ‚úÖ **Compensation Logic**: Implement rollback for failed workflow steps
           - ‚úÖ **State Management**: Use workflow variables for state, not external storage


        **üìä Error Handling & Resilience:**
        10. **Workflow Error Handling:**
            - ‚úÖ **Try-Catch Blocks**: Wrap activity calls in proper error handling
            - ‚úÖ **Retry Logic**: Implement workflow-level retry mechanisms
            - ‚úÖ **Compensation**: Rollback completed steps on failures
            - ‚úÖ **Error Propagation**: Return meaningful error information
            - ‚úÖ **Logging**: Log errors with appropriate context and correlation IDs

        11. **Retry Strategies:**
            - ‚úÖ **Exponential Backoff**: Use increasing delays between retries
            - ‚úÖ **Jitter**: Add randomness to retry delays to prevent thundering herd
            - ‚úÖ **Maximum Attempts**: Set reasonable limits on retry attempts
            - ‚úÖ **Error Classification**: Different retry strategies for different error types
            - ‚úÖ **Monitoring**: Track retry patterns and success rates



        **üìà Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - ‚úÖ **Workflow Metrics**: Track workflow execution times and success rates
            - ‚úÖ **Activity Metrics**: Monitor activity performance and error rates
            - ‚úÖ **Worker Metrics**: Track worker health and task processing rates
            - ‚úÖ **Retry Metrics**: Monitor retry patterns and success rates
            - ‚úÖ **Resource Usage**: Monitor memory, CPU, and connection usage

        13. **Logging & Tracing:**
            - ‚úÖ **Structured Logging**: Use consistent log formats and field names
            - ‚úÖ **Correlation IDs**: Include workflow and activity IDs in all logs
            - ‚úÖ **Context Information**: Log relevant workflow state and parameters
            - ‚úÖ **Error Details**: Include full error context and stack traces
            - ‚úÖ **Performance Logging**: Log slow operations and bottlenecks

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Using system time or random numbers in workflows
        - ‚ùå Making direct I/O calls from workflows
        - ‚ùå Using global mutable state in workflows
        - ‚ùå Non-idempotent activities without idempotency keys
        - ‚ùå Missing timeout configurations for activities
        - ‚ùå No error handling or retry logic
        - ‚ùå Missing heartbeating for long-running activities
        - ‚ùå No monitoring or metrics implementation
        - ‚ùå Hardcoded retry policies or timeout values
        - ‚ùå Missing compensation logic for failed operations

        **üîç Review Focus Areas:**
        - Verify workflow determinism and no side effects
        - Check activity idempotency and error handling
        - Ensure proper worker configuration and concurrency
        - Validate timeout and retry policy configurations
        - Review error handling and compensation logic
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Workflow execution ‚Üí `temporal_workflows_total{workflow_type, status}`
          - Workflow duration ‚Üí `temporal_workflow_duration_seconds{workflow_type}`
          - Activity execution ‚Üí `temporal_activities_total{activity_type, status}`
          - Activity duration ‚Üí `temporal_activity_duration_seconds{activity_type}`
          - Worker metrics ‚Üí `temporal_worker_tasks_total{worker_id, status}`
          - Retry attempts ‚Üí `temporal_retries_total{operation_type, reason}`
          - Error handling ‚Üí `temporal_errors_total{type, operation}`
          - Timeout occurrences ‚Üí `temporal_timeouts_total{type, operation}`
    - path: "**/*{temporal*,worker*,workflow*,task*,activit*}*"
      instructions: |
        **Comprehensive Temporal Code Review Checklist:**

        **üîí Workflow Determinism (Critical):**
        1. **Deterministic Operations:**
           - ‚úÖ **No System Time**: Never use `System.currentTimeMillis()`, `new Date()`, or similar
           - ‚úÖ **No Random Numbers**: Never use `Math.random()`, `Random.nextInt()`, or similar
           - ‚úÖ **No UUID Generation**: Never use `UUID.randomUUID()` or similar
           - ‚úÖ **Use Temporal APIs**: Use `workflow.now()`, `workflow.randomUUID()`, `workflow.sideEffect()`
           - ‚ö†Ô∏è **Critical**: Any non-deterministic operation will cause workflow replay failures

        2. **Side Effect Isolation:**
           - ‚úÖ **No Direct I/O**: Never make database calls, network requests, or file system access
           - ‚úÖ **No External Services**: Never call external APIs or services directly
           - ‚úÖ **Delegate to Activities**: All side effects must be in Activities, not Workflows
           - ‚úÖ **Pure Functions**: Workflows should be pure, deterministic functions

        3. **State Management:**
           - ‚úÖ **No Global State**: Never use static variables or global mutable state
           - ‚úÖ **No Concurrent Access**: Avoid concurrent data structures unless managed by Temporal
           - ‚úÖ **Immutable Data**: Use immutable data structures when possible
           - ‚úÖ **Workflow State**: Store state in workflow variables, not external storage

        **üìã Activity Design & Implementation:**
        4. **Activity Idempotency:**
           - ‚úÖ **Always Idempotent**: Design activities to be safely retryable
           - ‚úÖ **Idempotency Keys**: Use unique keys for operations with side effects
           - ‚úÖ **State Checks**: Check current state before performing operations
           - ‚úÖ **Compensation Logic**: Implement rollback mechanisms for failed operations
           - ‚úÖ **No Side Effects**: Activities should be safe to execute multiple times

        5. **Activity Error Handling:**
           - ‚úÖ **Retry Policies**: Configure appropriate retry policies for different error types
           - ‚úÖ **Error Classification**: Distinguish between retryable and non-retryable errors
           - ‚úÖ **Timeout Configuration**: Set appropriate `StartToCloseTimeout` values
           - ‚úÖ **Heartbeating**: Implement heartbeating for long-running activities
           - ‚úÖ **Circuit Breakers**: Use circuit breakers for external service calls

        6. **Activity Timeouts:**
           - ‚úÖ **StartToCloseTimeout**: Maximum time for activity execution
           - ‚úÖ **ScheduleToStartTimeout**: Maximum time to wait for worker assignment
           - ‚úÖ **HeartbeatTimeout**: Maximum time between heartbeats
           - ‚úÖ **ScheduleToCloseTimeout**: Maximum time from scheduling to completion
           - ‚úÖ **Retry Policies**: Configure retry delays and maximum attempts

        **‚öôÔ∏è Worker Configuration & Management:**
        7. **Worker Concurrency:**
           - ‚úÖ **Activity Concurrency**: Set `MaxConcurrentActivityExecutionSize` appropriately
           - ‚úÖ **Workflow Concurrency**: Set `MaxConcurrentWorkflowTaskExecutionSize`
           - ‚úÖ **Task Polling**: Configure `MaxConcurrentActivityTaskPollers`
           - ‚úÖ **Workflow Polling**: Configure `MaxConcurrentWorkflowTaskPollers`
           - ‚úÖ **Resource Limits**: Balance concurrency with available system resources

        8. **Worker Lifecycle:**
           - ‚úÖ **Graceful Shutdown**: Implement proper shutdown procedures
           - ‚úÖ **Health Checks**: Monitor worker health and availability
           - ‚úÖ **Connection Management**: Handle Temporal service connection failures
           - ‚úÖ **Task Processing**: Ensure tasks are processed efficiently
           - ‚úÖ **Error Recovery**: Implement worker-level error recovery mechanisms

        **üîÑ Workflow Orchestration:**
        9. **Workflow Structure:**
           - ‚úÖ **Single Responsibility**: Each workflow should have one clear purpose
           - ‚úÖ **Granular Activities**: Break complex operations into smaller activities
           - ‚úÖ **Error Propagation**: Properly handle and propagate errors from activities
           - ‚úÖ **Compensation Logic**: Implement rollback for failed workflow steps
           - ‚úÖ **State Management**: Use workflow variables for state, not external storage


        **üìä Error Handling & Resilience:**
        10. **Workflow Error Handling:**
            - ‚úÖ **Try-Catch Blocks**: Wrap activity calls in proper error handling
            - ‚úÖ **Retry Logic**: Implement workflow-level retry mechanisms
            - ‚úÖ **Compensation**: Rollback completed steps on failures
            - ‚úÖ **Error Propagation**: Return meaningful error information
            - ‚úÖ **Logging**: Log errors with appropriate context and correlation IDs

        11. **Retry Strategies:**
            - ‚úÖ **Exponential Backoff**: Use increasing delays between retries
            - ‚úÖ **Jitter**: Add randomness to retry delays to prevent thundering herd
            - ‚úÖ **Maximum Attempts**: Set reasonable limits on retry attempts
            - ‚úÖ **Error Classification**: Different retry strategies for different error types
            - ‚úÖ **Monitoring**: Track retry patterns and success rates



        **üìà Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - ‚úÖ **Workflow Metrics**: Track workflow execution times and success rates
            - ‚úÖ **Activity Metrics**: Monitor activity performance and error rates
            - ‚úÖ **Worker Metrics**: Track worker health and task processing rates
            - ‚úÖ **Retry Metrics**: Monitor retry patterns and success rates
            - ‚úÖ **Resource Usage**: Monitor memory, CPU, and connection usage

        13. **Logging & Tracing:**
            - ‚úÖ **Structured Logging**: Use consistent log formats and field names
            - ‚úÖ **Correlation IDs**: Include workflow and activity IDs in all logs
            - ‚úÖ **Context Information**: Log relevant workflow state and parameters
            - ‚úÖ **Error Details**: Include full error context and stack traces
            - ‚úÖ **Performance Logging**: Log slow operations and bottlenecks

        **üö® Common Anti-Patterns to Flag:**
        - ‚ùå Using system time or random numbers in workflows
        - ‚ùå Making direct I/O calls from workflows
        - ‚ùå Using global mutable state in workflows
        - ‚ùå Non-idempotent activities without idempotency keys
        - ‚ùå Missing timeout configurations for activities
        - ‚ùå No error handling or retry logic
        - ‚ùå Missing heartbeating for long-running activities
        - ‚ùå No monitoring or metrics implementation
        - ‚ùå Hardcoded retry policies or timeout values
        - ‚ùå Missing compensation logic for failed operations

        **üîç Review Focus Areas:**
        - Verify workflow determinism and no side effects
        - Check activity idempotency and error handling
        - Ensure proper worker configuration and concurrency
        - Validate timeout and retry policy configurations
        - Review error handling and compensation logic
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **üìä Prometheus Metrics Opportunities:**
        - üîç **Automatically suggest metrics when seeing:**
          - Workflow execution ‚Üí `temporal_workflows_total{workflow_type, status}`
          - Workflow duration ‚Üí `temporal_workflow_duration_seconds{workflow_type}`
          - Activity execution ‚Üí `temporal_activities_total{activity_type, status}`
          - Activity duration ‚Üí `temporal_activity_duration_seconds{activity_type}`
          - Worker metrics ‚Üí `temporal_worker_tasks_total{worker_id, status}`
          - Retry attempts ‚Üí `temporal_retries_total{operation_type, reason}`
          - Error handling ‚Üí `temporal_errors_total{type, operation}`
          - Timeout occurrences ‚Üí `temporal_timeouts_total{type, operation}`


  # =============================================================================
  # GLOBAL REVIEW INSTRUCTIONS
  # =============================================================================
  # 
  # These instructions apply to ALL code changes regardless of technology or path.
  # They serve as a comprehensive checklist for code quality, security, and best practices.
  # 
  # Teams can customize these instructions to match their specific:
  # - Coding standards and style guides
  # - Security requirements
  # - Testing policies
  # - Documentation standards
  # - Performance expectations
  global_instructions: |
    **üîç General Code Review Checklist:**
    
    **üìù Code Quality:**
    - ‚úÖ Functions and methods have clear, descriptive names
    - ‚úÖ Complex logic is properly documented with comments
    - ‚úÖ No hardcoded values or magic numbers
    - ‚úÖ Error handling is comprehensive and appropriate
    - ‚úÖ Code follows consistent formatting and style
    - ‚úÖ No duplicate or redundant code
    - ‚úÖ Proper separation of concerns
    
    **üîí Security:**
    - ‚úÖ No sensitive information (passwords, keys, tokens) in code
    - ‚úÖ Input validation and sanitization where appropriate
    - ‚úÖ Authentication and authorization checks are in place
    - ‚úÖ No SQL injection vulnerabilities
    - ‚úÖ No XSS vulnerabilities in web applications
    - ‚úÖ Secure communication protocols (HTTPS, TLS)
    - ‚úÖ Proper session management and timeout handling
    
    **üß™ Testing:**
    - ‚úÖ New functionality has corresponding tests
    - ‚úÖ Tests are meaningful and cover edge cases
    - ‚úÖ Test names clearly describe what they're testing
    - ‚úÖ No test code in production files
    - ‚úÖ Tests are fast and reliable
    - ‚úÖ Test coverage is adequate for critical paths
    - ‚úÖ Integration tests for complex workflows
    
    **üìö Documentation:**
    - ‚úÖ Public APIs are documented
    - ‚úÖ Complex business logic has inline comments
    - ‚úÖ README files are updated if needed
    - ‚úÖ Configuration changes are documented
    - ‚úÖ Architecture decisions are documented
    - ‚úÖ Setup and deployment instructions are current
    
    **üöÄ Performance:**
    - ‚úÖ No obvious performance bottlenecks
    - ‚úÖ Database queries are optimized
    - ‚úÖ Resource cleanup is handled properly
    - ‚úÖ No memory leaks or resource leaks
    - ‚úÖ Efficient data structures are used
    - ‚úÖ Caching is implemented where appropriate
    - ‚úÖ Async operations are used for I/O-bound tasks

  # =============================================================================
  # CODE QUALITY METRICS & THRESHOLDS
  # =============================================================================
  # 
  # These metrics help maintain code quality by flagging potential issues.
  # Thresholds can be adjusted based on your team's standards and project requirements.
  # 
  # Each metric includes:
  # - threshold: The value that triggers a review comment
  # - enabled: Whether this metric is active
  # - instructions: Explanation of why the threshold matters and how to address it
  metrics:
    # Function complexity measures the number of decision points in a function
    # Higher complexity makes code harder to understand, test, and maintain
    function_complexity:
      threshold: 15        # Cyclomatic complexity > 15 triggers review
      enabled: true
      instructions: |
        Functions with cyclomatic complexity > 15 should be refactored into smaller,
        more focused functions for better maintainability and testability.
        
        COMPLEXITY FACTORS:
        - if/else statements
        - switch cases
        - loops (for, while, do-while)
        - logical operators (&&, ||)
        - catch blocks
        
        REFACTORING STRATEGIES:
        - Extract complex conditions into well-named boolean functions
        - Split large functions into smaller, focused functions
        - Use early returns to reduce nesting
        - Consider using strategy pattern for complex logic

    # Function length measures the number of lines in a function
    # Longer functions are harder to understand and maintain
    function_length:
      threshold: 150       # Functions > 150 lines trigger review
      enabled: true
      instructions: |
        Functions longer than 150 lines should be broken down into smaller,
        more focused functions for better readability and maintainability.
        
        REFACTORING STRATEGIES:
        - Extract logical blocks into separate functions
        - Use helper functions for repetitive code
        - Consider breaking into multiple smaller functions
        - Use classes/structs to group related functionality
        
        EXCEPTIONS:
        - Data processing functions that must process large datasets
        - Generated code (though this should be minimized)
        - Legacy code that's being gradually refactored

    # File length measures the total lines in a file
    # Very long files can be hard to navigate and understand
    file_length:
      threshold: 500       # Files > 500 lines trigger review
      enabled: true
      instructions: |
        Files longer than 500 lines should be considered for splitting into
        multiple files or modules for better organization.
        
        SPLITTING STRATEGIES:
        - Group related functionality into separate files
        - Extract utility functions into shared modules
        - Split large classes into multiple smaller classes
        - Create separate files for different concerns
        
        ORGANIZATION TIPS:
        - Keep related functionality together
        - Use clear file naming conventions
        - Consider using packages/modules for organization
        - Maintain logical separation of concerns

    # Nesting depth measures how deeply code is nested
    # Deep nesting makes code hard to read and understand
    nesting_depth:
      threshold: 4         # Nesting > 4 levels triggers review
      enabled: true
      instructions: |
        Code with nesting depth > 4 levels should be refactored to reduce
        complexity and improve readability.
        
        NESTING REDUCTION TECHNIQUES:
        - Use early returns to avoid deep nesting
        - Extract complex conditions into boolean functions
        - Use guard clauses at the beginning of functions
        - Consider using switch statements instead of if-else chains
        - Break complex logic into smaller functions
        
        EXAMPLE REFACTORING:
        ```go
        // Before (deep nesting)
        if user != nil {
            if user.IsActive() {
                if user.HasPermission("read") {
                    if data != nil {
                        // process data
                    }
                }
            }
        }
        
        // After (early returns)
        if user == nil || !user.IsActive() || !user.HasPermission("read") {
            return errors.New("unauthorized")
        }
        if data == nil {
            return errors.New("no data")
        }
        // process data
        ```

  # =============================================================================
  # REVIEW BEHAVIOR CONFIGURATION
  # =============================================================================
  # 
  # These settings control how CodeRabbit behaves during reviews.
  # Adjust these based on your team's preferences and workflow requirements.
  behavior:
    # Review scope determines which files are included in reviews
    review_all_files: true        # Review all changed files
    review_test_files: true       # Include test files in reviews
    review_documentation: true    # Review documentation changes
    
    # Comment behavior controls how CodeRabbit provides feedback
    suggest_fixes: true           # Suggest specific fixes for issues
    explain_why: true             # Explain why changes are suggested
    
    # Review depth controls the thoroughness of reviews
    thoroughness: "high"          # Options: "low", "medium", "high"
    focus_on_critical: true       # Prioritize critical issues
    
    # Language and framework awareness
    language_agnostic: true       # Work with any programming language
    framework_aware: true         # Understand framework-specific patterns

  # =============================================================================
  # SECURITY SCANNING CONFIGURATION
  # =============================================================================
  # 
  # Security scanning helps identify potential security vulnerabilities
  # and ensures code follows security best practices.
  security:
    enabled: true                 # Enable security scanning
    scan_dependencies: true       # Check for vulnerable dependencies
    scan_secrets: true            # Detect hardcoded secrets
    scan_vulnerabilities: true    # Identify security vulnerabilities
    
    # Security rules define specific security checks
    rules:
      - name: "no_hardcoded_secrets"
        enabled: true
        severity: "high"          # Critical security issue
        description: |
          Detect hardcoded passwords, API keys, tokens, or other sensitive
          information that should be stored in environment variables or
          secure configuration management systems.
        
      - name: "input_validation"
        enabled: true
        severity: "medium"        # Important security consideration
        description: |
          Ensure all user inputs are properly validated and sanitized
          to prevent injection attacks and data corruption.
        
      - name: "authentication_checks"
        enabled: true
        severity: "high"          # Critical security requirement
        description: |
          Verify that proper authentication mechanisms are in place
          for all protected resources and operations.
        
      - name: "authorization_checks"
        enabled: true
        severity: "high"          # Critical security requirement
        description: |
          Ensure that authorization checks are performed to verify
          users have permission to access specific resources.

# =============================================================================
# CONFIGURATION NOTES & CUSTOMIZATION GUIDE
# =============================================================================
#
# This base configuration provides a solid foundation for most projects.
# However, you may want to customize it based on your specific needs:
#
# 1. ADJUSTING THRESHOLDS:
#    - Modify the values in the metrics section based on your team's standards
#    - Consider your project's complexity and team experience level
#    - Start with conservative thresholds and adjust based on feedback
#
# 2. ADDING CUSTOM LABELS:
#    - Add new labels to the labeling_instructions section
#    - Provide clear, specific criteria for when to apply each label
#    - Include examples to help CodeRabbit make accurate suggestions
#
# 3. CUSTOMIZING GLOBAL INSTRUCTIONS:
#    - Modify global_instructions to match your team's coding standards
#    - Add project-specific requirements or guidelines
#    - Include links to your style guides or documentation
#
# 4. SECURITY REQUIREMENTS:
#    - Adjust security rules based on your application's security needs
#    - Add industry-specific security requirements
#    - Consider compliance requirements (SOC2, HIPAA, GDPR, etc.)
#
# 5. PERFORMANCE EXPECTATIONS:
#    - Modify performance thresholds based on your application's requirements
#    - Consider your infrastructure and user expectations
#    - Add performance monitoring and alerting requirements
#
# For more information and examples, see the README.md file and the
# technology-specific configuration files in the configs/ directory.

