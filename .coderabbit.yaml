# .coderabbit.base.yaml - Base configuration template


version: 1
reviews:

  # =============================================================================
  # AUTOMATIC LABELING CONFIGURATION
  # =============================================================================
  # 
  # When enabled, CodeRabbit will automatically suggest and apply labels
  # based on the content and scope of pull requests. This helps with:
  # - PR categorization and filtering
  # - Automated workflows and notifications
  # - Release note generation
  # - Team communication and prioritization
  auto_apply_labels: true

  # Label instructions define when and how to apply specific labels
  # Each label has clear criteria to help CodeRabbit make accurate suggestions
  labeling_instructions:
    # --- Core Change Types ---
    # These labels cover the fundamental types of changes in software development
    
    - label: "feature"
      instructions: |
        Apply when the pull request introduces new functionality or a significant new capability.
        Look for new user stories, API endpoints, or major additions to existing features.
        
        EXAMPLES:
        - New API endpoints or methods
        - New user interface components
        - New business logic or algorithms
        - New configuration options
        - New integration points with external services

    - label: "bugfix"
      instructions: |
        Apply when the pull request primarily fixes an identified bug, defect, or incorrect behavior.
        Often addresses a specific issue or error report.
        
        EXAMPLES:
        - Fixing incorrect calculations or logic
        - Resolving error handling issues
        - Correcting UI display problems
        - Fixing performance bottlenecks
        - Resolving integration failures

    - label: "refactor"
      instructions: |
        Apply when the pull request restructures or cleans up existing code without altering its external behavior.
        Focus on code readability, maintainability, or internal design improvements.
        
        EXAMPLES:
        - Renaming variables or functions for clarity
        - Extracting common code into shared functions
        - Improving code organization and structure
        - Updating code style to match guidelines
        - Optimizing internal algorithms without changing behavior

    - label: "documentation"
      instructions: |
        Apply when the pull request primarily modifies documentation.
        Look for changes in `.md`, `.rst`, `docs/`, `README.md`, or similar documentation files.
        
        EXAMPLES:
        - Updating README files
        - Adding inline code comments
        - Creating or updating API documentation
        - Writing user guides or tutorials
        - Updating configuration examples

    - label: "chore"
      instructions: |
        Apply for routine maintenance, dependency updates, build system changes, or minor configuration adjustments.
        These are non-functional changes that don't directly add features or fix bugs in the application logic.
        
        EXAMPLES:
        - Updating package dependencies
        - Modifying build scripts or CI/CD configs
        - Updating development environment setup
        - Code formatting or linting fixes
        - Repository maintenance tasks

    - label: "tests"
      instructions: |
        Apply when the pull request primarily adds new tests, updates existing tests, or refactors test code.
        Look for changes in `test/`, `__tests__/`, `*.test.ts`, or other dedicated test directories/files.
        
        EXAMPLES:
        - Adding unit tests for new functionality
        - Improving test coverage for existing code
        - Refactoring test structure or organization
        - Adding integration or end-to-end tests
        - Updating test data or fixtures
    
    - label: "security"
      instructions: |
        Apply when the pull request addresses security vulnerabilities, implements security features,
        or modifies authentication/authorization logic. Look for changes in security-related code,
        encryption, input validation, or access control mechanisms.
        
        EXAMPLES:
        - Adding input validation and sanitization
        - Implementing authentication mechanisms
        - Adding authorization checks
        - Updating encryption or hashing
        - Fixing security vulnerabilities
        - Adding security headers or policies

    - label: "performance"
      instructions: |
        Apply when the pull request optimizes performance, reduces latency, improves throughput,
        or addresses performance bottlenecks. Look for changes in caching, algorithm improvements, or
        resource optimization changes.
        
        EXAMPLES:
        - Adding caching mechanisms
        - Optimizing database queries
        - Improving algorithm efficiency
        - Reducing memory usage
        - Optimizing network requests
        - Adding performance monitoring

    - label: "dependencies"
      instructions: |
        Apply when the pull request updates, adds, or removes dependencies, packages,
        or external libraries. Look for changes in package.json, requirements.txt,
        go.mod, or similar dependency files.
        
        EXAMPLES:
        - Updating package versions
        - Adding new dependencies
        - Removing unused dependencies
        - Updating lock files
        - Changing dependency sources

  # =============================================================================
  # PATH-SPECIFIC INSTRUCTIONS
  # =============================================================================
  # 
  # This section will be automatically populated by the merge tool
  # from individual technology-specific configuration files in configs/*/
  # 
  # Each technology (HTTP, Redis, Kafka, etc.) has its own path_instructions.yaml
  # file that gets merged here during the build process.
  path_instructions:
    - path: "**/{http,client,api,network}*/**"
      instructions: |
        **Comprehensive HTTP Client Code Review Checklist:**

        **ğŸ”§ Performance & Resource Management:**
        1. **Client Reuse & Connection Pooling:** 
           - âœ… Reuse HTTP client instances (don't create new clients per request)
           - âœ… Configure connection pool settings: `MaxIdleConns`, `MaxConnsPerHost`, `MaxIdleConnsPerHost`
           - âœ… Set appropriate `IdleConnTimeout` to prevent stale connections
           - âœ… Use `DisableKeepAlives: false` for better performance (unless specifically needed)

        2. **Timeouts (CRITICAL):**
           - âœ… Set `ConnectTimeout` for TCP connection establishment (e.g., 5-30s)
           - âœ… Set `RequestTimeout` for total request duration (e.g., 10-60s)
           - âœ… Set `ReadTimeout` for response body reading
           - âœ… Set `WriteTimeout` for request body writing
           - âš ï¸ Never use infinite timeouts - this can cause resource leaks

        3. **Resource Cleanup:**
           - âœ… Always close response body: `defer resp.Body.Close()` (Go) or equivalent
           - âœ… Handle response body even if you don't need it (read to EOF or close)
           - âœ… Use `io.Copy(io.Discard, resp.Body)` for discarding unwanted responses

        4. **Request Headers & Authentication:**
           - âœ… Set appropriate `User-Agent` header
           - âœ… Use secure authentication methods (Bearer tokens, API keys)
           - âœ… Don't log sensitive headers (Authorization, Cookie, etc.)
           - âœ… Set `Content-Type` and `Accept` headers appropriately

        **ğŸ“Š Error Handling & Resilience:**
        5. **Status Code Handling:**
           - âœ… Handle all status codes: 2xx (success), 4xx (client error), 5xx (server error)
           - âœ… Check `resp.StatusCode` before processing response body
           - âœ… Provide meaningful error messages for different status codes
           - âœ… Handle redirects appropriately (3xx status codes)

        6. **Retry Logic:**
           - âœ… Implement exponential backoff with jitter for transient errors
           - âœ… Only retry idempotent operations (GET, PUT, DELETE, not POST)
           - âœ… Set maximum retry attempts to prevent infinite loops
           - âœ… Use appropriate retry conditions (5xx errors, network timeouts)

        7. **Error Handling:**
           - âœ… Use language-appropriate error handling patterns
           - âœ… Wrap errors with context: `fmt.Errorf("failed to make request: %w", err)`
           - âœ… Handle network errors separately from HTTP errors
           - âœ… Provide actionable error messages for debugging

        **ğŸ“ˆ Observability & Monitoring:**
        8. **Logging & Tracing:**
           - âœ… Log request details (method, URL, headers) at DEBUG level
           - âœ… Log response status and timing at INFO level
           - âœ… Log errors with full context (request details, response status)
           - âœ… Use structured logging with consistent field names
           - âœ… Implement request/response correlation IDs for tracing

        9. **Metrics & Monitoring:**
          - âœ… Track request duration, status codes, and error rates
          - âœ… Monitor connection pool utilization
          - âœ… Alert on high error rates or timeout percentages
          - âœ… Use histetheus metrics for comprehensive monitoring

          **ğŸ“Š Prometheus Metrics Opportunities:**
          - ğŸ” **Automatically suggest metrics when seeing:**
            - HTTP requests â†’ `http_requests_total{method, endpoint, status_code}`
            - Response times â†’ `http_request_duration_seconds{method, endpoint}`
            - Error handling â†’ `http_errors_total{type, endpoint, status_code}`
            - Timeout handling â†’ `http_timeouts_total{type, endpoint}`
            - Connection pools â†’ `http_connection_pool_size{state}`
            - Retry logic â†’ `http_retries_total{endpoint, reason}`
            - Circuit breakers â†’ `http_circuit_breaker_state{endpoint}`

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Creating new HTTP client per request
        - âŒ Missing timeout configurations
        - âŒ Not closing response bodies
        - âŒ Ignoring HTTP status codes
        - âŒ Hardcoded URLs or credentials
        - âŒ No error handling for network failures
        - âŒ Infinite retry loops
        - âŒ Logging sensitive information

        **ğŸ” Review Focus Areas:**
        - Look for proper client configuration and reuse
        - Verify timeout settings are reasonable and not infinite
        - Check response body handling and cleanup
        - Ensure proper error handling and logging
        - Validate security practices (HTTPS, auth, headers)
        - Review retry logic for correctness and safety
        - Identify opportunities for Prometheus metrics
        - Suggest appropriate monitoring and alerting

    - path: "**/*{http*,client*,api*,network*}*"
      instructions: |
        **Comprehensive HTTP Client Code Review Checklist:**

        **ğŸ”§ Performance & Resource Management:**
        1. **Client Reuse & Connection Pooling:** 
           - âœ… Reuse HTTP client instances (don't create new clients per request)
           - âœ… Configure connection pool settings: `MaxIdleConns`, `MaxConnsPerHost`, `MaxIdleConnsPerHost`
           - âœ… Set appropriate `IdleConnTimeout` to prevent stale connections
           - âœ… Use `DisableKeepAlives: false` for better performance (unless specifically needed)

        2. **Timeouts (CRITICAL):**
           - âœ… Set `ConnectTimeout` for TCP connection establishment (e.g., 5-30s)
           - âœ… Set `RequestTimeout` for total request duration (e.g., 10-60s)
           - âœ… Set `ReadTimeout` for response body reading
           - âœ… Set `WriteTimeout` for request body writing
           - âš ï¸ Never use infinite timeouts - this can cause resource leaks

        3. **Resource Cleanup:**
           - âœ… Always close response body: `defer resp.Body.Close()` (Go) or equivalent
           - âœ… Handle response body even if you don't need it (read to EOF or close)
           - âœ… Use `io.Copy(io.Discard, resp.Body)` for discarding unwanted responses

        4. **Request Headers & Authentication:**
           - âœ… Set appropriate `User-Agent` header
           - âœ… Use secure authentication methods (Bearer tokens, API keys)
           - âœ… Don't log sensitive headers (Authorization, Cookie, etc.)
           - âœ… Set `Content-Type` and `Accept` headers appropriately

        **ğŸ“Š Error Handling & Resilience:**
        5. **Status Code Handling:**
           - âœ… Handle all status codes: 2xx (success), 4xx (client error), 5xx (server error)
           - âœ… Check `resp.StatusCode` before processing response body
           - âœ… Provide meaningful error messages for different status codes
           - âœ… Handle redirects appropriately (3xx status codes)

        6. **Retry Logic:**
           - âœ… Implement exponential backoff with jitter for transient errors
           - âœ… Only retry idempotent operations (GET, PUT, DELETE, not POST)
           - âœ… Set maximum retry attempts to prevent infinite loops
           - âœ… Use appropriate retry conditions (5xx errors, network timeouts)

        7. **Error Handling:**
           - âœ… Use language-appropriate error handling patterns
           - âœ… Wrap errors with context: `fmt.Errorf("failed to make request: %w", err)`
           - âœ… Handle network errors separately from HTTP errors
           - âœ… Provide actionable error messages for debugging

        **ğŸ“ˆ Observability & Monitoring:**
        8. **Logging & Tracing:**
           - âœ… Log request details (method, URL, headers) at DEBUG level
           - âœ… Log response status and timing at INFO level
           - âœ… Log errors with full context (request details, response status)
           - âœ… Use structured logging with consistent field names
           - âœ… Implement request/response correlation IDs for tracing

        9. **Metrics & Monitoring:**
          - âœ… Track request duration, status codes, and error rates
          - âœ… Monitor connection pool utilization
          - âœ… Alert on high error rates or timeout percentages
          - âœ… Use histetheus metrics for comprehensive monitoring

          **ğŸ“Š Prometheus Metrics Opportunities:**
          - ğŸ” **Automatically suggest metrics when seeing:**
            - HTTP requests â†’ `http_requests_total{method, endpoint, status_code}`
            - Response times â†’ `http_request_duration_seconds{method, endpoint}`
            - Error handling â†’ `http_errors_total{type, endpoint, status_code}`
            - Timeout handling â†’ `http_timeouts_total{type, endpoint}`
            - Connection pools â†’ `http_connection_pool_size{state}`
            - Retry logic â†’ `http_retries_total{endpoint, reason}`
            - Circuit breakers â†’ `http_circuit_breaker_state{endpoint}`

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Creating new HTTP client per request
        - âŒ Missing timeout configurations
        - âŒ Not closing response bodies
        - âŒ Ignoring HTTP status codes
        - âŒ Hardcoded URLs or credentials
        - âŒ No error handling for network failures
        - âŒ Infinite retry loops
        - âŒ Logging sensitive information

        **ğŸ” Review Focus Areas:**
        - Look for proper client configuration and reuse
        - Verify timeout settings are reasonable and not infinite
        - Check response body handling and cleanup
        - Ensure proper error handling and logging
        - Validate security practices (HTTPS, auth, headers)
        - Review retry logic for correctness and safety
        - Identify opportunities for Prometheus metrics
        - Suggest appropriate monitoring and alerting

    - path: "**/{kafka,producer,consumer,broker,topic,stream}*/**"
      instructions: |
        **Comprehensive Kafka Code Review Checklist:**

        **ğŸ”§ Client Lifecycle & Resource Management:**
        1. **Singleton Client Pattern:**
           - âœ… Reuse Kafka client instances (Producer, Consumer) throughout application lifecycle
           - âœ… Avoid creating new clients per request/operation
           - âœ… Use dependency injection or singleton patterns for client management
           - âš ï¸ Never create clients inside loops or per-message functions

        2. **Connection Management:**
           - âœ… Configure appropriate connection pool settings
           - âœ… Set reasonable connection timeouts and retry policies
           - âœ… Handle connection failures gracefully with exponential backoff
           - âœ… Implement proper client cleanup and shutdown procedures

        **ğŸ“¤ Producer Configuration & Best Practices:**
        3. **Performance Tuning:**
           - âœ… Configure `MaxBatchBytes` for optimal batch sizes (e.g., 16KB-1MB)
           - âœ… Set `MaxBufferedRecords` to control memory usage
           - âœ… Use `ProducerLinger` to balance latency vs throughput
           - âœ… Configure `RecordRetries` for failed message handling (typically 3-5)
           - âœ… Set `ProduceRequestTimeout` to prevent indefinite hangs

        4. **Reliability & Consistency:**
           - âœ… Enable idempotent producers (`enable.idempotence=true`) to prevent duplicates
           - âœ… Configure `RequiredAcks` based on durability needs:
             - `LeaderAck` for high throughput, lower durability
             - `AllISRAcks` for highest durability, lower throughput
           - âœ… Implement proper error handling for different failure scenarios

        5. **Batching & Compression:**
           - âœ… Enable compression (Gzip, Snappy, LZ4, Zstd) for network efficiency
           - âœ… Tune `batch.size` and `linger.ms` for optimal compression ratios
           - âœ… Ensure `max.request.size` accommodates your batch sizes

        **ğŸ“¥ Consumer Configuration & Best Practices:**
        6. **Performance & Efficiency:**
           - âœ… Configure `FetchMinBytes` and `FetchMaxBytes` for optimal throughput
           - âœ… Set `MaxConcurrentFetches` based on available resources
           - âœ… Use appropriate `SessionTimeout` and `RebalanceTimeout` values
           - âœ… Configure `HeartbeatInterval` for stable consumer group membership

        7. **Offset Management:**
           - âœ… Use `enable.auto.commit=false` for manual control when needed
           - âœ… Handle offset commit failures gracefully
           - âœ… Implement offset reset strategies for consumer group scenarios
           - âœ… Monitor consumer lag and implement alerting

        8. **Consumer Group Management:**
           - âœ… Ensure consumers are part of a consumer group
           - âœ… Handle rebalancing events properly
           - âœ… Implement graceful shutdown procedures
           - âœ… Monitor consumer group health and stability

        **ğŸ›¡ï¸ Security & Best Practices:**
        9. **Authentication & Authorization:**
           - âœ… Use secure credential management (not hardcoded)

        10. **Data Security:**
            - âœ… Use encryption for sensitive data in transit
            - âœ… Implement proper key management for encrypted topics
            - âœ… Audit access patterns and implement monitoring
            - âœ… Follow principle of least privilege for topic access

        **ğŸ“Š Error Handling & Resilience:**
        11. **Error Classification & Handling:**
            - âœ… Distinguish between transient and permanent errors
            - âœ… Implement retry logic with exponential backoff for transient errors
            - âœ… Handle permanent errors gracefully (log, alert, circuit break)
            - âœ… Implement dead letter queues for failed messages
            - âœ… Monitor error rates and implement alerting

        12. **Circuit Breaker Patterns:**
            - âœ… Implement circuit breakers for broker failures
            - âœ… Monitor circuit breaker state and metrics
            - âœ… Implement fallback mechanisms when possible

        **ğŸ“ˆ Observability & Monitoring:**
        13. **Metrics & Monitoring:**
            - âœ… Track producer/consumer throughput and latency
            - âœ… Monitor consumer lag and offset commit success rates
            - âœ… Track error rates and failure patterns
            - âœ… Monitor connection pool utilization and health
            - âœ… Implement health checks for Kafka clients

        14. **Logging & Tracing:**
            - âœ… Log important operations (produce/consume, errors, rebalances)
            - âœ… Include correlation IDs for request tracing
            - âœ… Log configuration changes and client lifecycle events
            - âœ… Use structured logging with consistent field names

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Creating new Kafka clients per operation
        - âŒ Missing error handling for network failures
        - âŒ No retry logic for transient errors
        - âŒ Missing timeout configurations
        - âŒ Hardcoded broker addresses or credentials
        - âŒ No monitoring or metrics implementation
        - âŒ Missing consumer group configuration
        - âŒ No offset commit error handling
        - âŒ Disabled idempotence without justification
        - âŒ No compression enabled for producers

        **ğŸ” Review Focus Areas:**
        - Verify client lifecycle management and reuse patterns
        - Check producer/consumer configuration for optimal settings
        - Ensure proper error handling and retry logic
        - Validate security configurations and authentication
        - Review offset management and consumer group handling
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Kafka producers â†’ `kafka_producer_messages_total{topic, status}`
          - Kafka consumers â†’ `kafka_consumer_messages_total{topic, partition}`
          - Message processing â†’ `kafka_message_duration_seconds{topic, operation}`
          - Error handling â†’ `kafka_errors_total{type, topic, operation}`
          - Consumer lag â†’ `kafka_consumer_lag{topic, partition, group}`
          - Connection health â†’ `kafka_connection_status{broker, state}`
          - Offset commits â†’ `kafka_offset_commits_total{topic, group, status}`

    - path: "**/*{kafka*,producer*,consumer*,broker*,topic*,stream*}*"
      instructions: |
        **Comprehensive Kafka Code Review Checklist:**

        **ğŸ”§ Client Lifecycle & Resource Management:**
        1. **Singleton Client Pattern:**
           - âœ… Reuse Kafka client instances (Producer, Consumer) throughout application lifecycle
           - âœ… Avoid creating new clients per request/operation
           - âœ… Use dependency injection or singleton patterns for client management
           - âš ï¸ Never create clients inside loops or per-message functions

        2. **Connection Management:**
           - âœ… Configure appropriate connection pool settings
           - âœ… Set reasonable connection timeouts and retry policies
           - âœ… Handle connection failures gracefully with exponential backoff
           - âœ… Implement proper client cleanup and shutdown procedures

        **ğŸ“¤ Producer Configuration & Best Practices:**
        3. **Performance Tuning:**
           - âœ… Configure `MaxBatchBytes` for optimal batch sizes (e.g., 16KB-1MB)
           - âœ… Set `MaxBufferedRecords` to control memory usage
           - âœ… Use `ProducerLinger` to balance latency vs throughput
           - âœ… Configure `RecordRetries` for failed message handling (typically 3-5)
           - âœ… Set `ProduceRequestTimeout` to prevent indefinite hangs

        4. **Reliability & Consistency:**
           - âœ… Enable idempotent producers (`enable.idempotence=true`) to prevent duplicates
           - âœ… Configure `RequiredAcks` based on durability needs:
             - `LeaderAck` for high throughput, lower durability
             - `AllISRAcks` for highest durability, lower throughput
           - âœ… Implement proper error handling for different failure scenarios

        5. **Batching & Compression:**
           - âœ… Enable compression (Gzip, Snappy, LZ4, Zstd) for network efficiency
           - âœ… Tune `batch.size` and `linger.ms` for optimal compression ratios
           - âœ… Ensure `max.request.size` accommodates your batch sizes

        **ğŸ“¥ Consumer Configuration & Best Practices:**
        6. **Performance & Efficiency:**
           - âœ… Configure `FetchMinBytes` and `FetchMaxBytes` for optimal throughput
           - âœ… Set `MaxConcurrentFetches` based on available resources
           - âœ… Use appropriate `SessionTimeout` and `RebalanceTimeout` values
           - âœ… Configure `HeartbeatInterval` for stable consumer group membership

        7. **Offset Management:**
           - âœ… Use `enable.auto.commit=false` for manual control when needed
           - âœ… Handle offset commit failures gracefully
           - âœ… Implement offset reset strategies for consumer group scenarios
           - âœ… Monitor consumer lag and implement alerting

        8. **Consumer Group Management:**
           - âœ… Ensure consumers are part of a consumer group
           - âœ… Handle rebalancing events properly
           - âœ… Implement graceful shutdown procedures
           - âœ… Monitor consumer group health and stability

        **ğŸ›¡ï¸ Security & Best Practices:**
        9. **Authentication & Authorization:**
           - âœ… Use secure credential management (not hardcoded)

        10. **Data Security:**
            - âœ… Use encryption for sensitive data in transit
            - âœ… Implement proper key management for encrypted topics
            - âœ… Audit access patterns and implement monitoring
            - âœ… Follow principle of least privilege for topic access

        **ğŸ“Š Error Handling & Resilience:**
        11. **Error Classification & Handling:**
            - âœ… Distinguish between transient and permanent errors
            - âœ… Implement retry logic with exponential backoff for transient errors
            - âœ… Handle permanent errors gracefully (log, alert, circuit break)
            - âœ… Implement dead letter queues for failed messages
            - âœ… Monitor error rates and implement alerting

        12. **Circuit Breaker Patterns:**
            - âœ… Implement circuit breakers for broker failures
            - âœ… Monitor circuit breaker state and metrics
            - âœ… Implement fallback mechanisms when possible

        **ğŸ“ˆ Observability & Monitoring:**
        13. **Metrics & Monitoring:**
            - âœ… Track producer/consumer throughput and latency
            - âœ… Monitor consumer lag and offset commit success rates
            - âœ… Track error rates and failure patterns
            - âœ… Monitor connection pool utilization and health
            - âœ… Implement health checks for Kafka clients

        14. **Logging & Tracing:**
            - âœ… Log important operations (produce/consume, errors, rebalances)
            - âœ… Include correlation IDs for request tracing
            - âœ… Log configuration changes and client lifecycle events
            - âœ… Use structured logging with consistent field names

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Creating new Kafka clients per operation
        - âŒ Missing error handling for network failures
        - âŒ No retry logic for transient errors
        - âŒ Missing timeout configurations
        - âŒ Hardcoded broker addresses or credentials
        - âŒ No monitoring or metrics implementation
        - âŒ Missing consumer group configuration
        - âŒ No offset commit error handling
        - âŒ Disabled idempotence without justification
        - âŒ No compression enabled for producers

        **ğŸ” Review Focus Areas:**
        - Verify client lifecycle management and reuse patterns
        - Check producer/consumer configuration for optimal settings
        - Ensure proper error handling and retry logic
        - Validate security configurations and authentication
        - Review offset management and consumer group handling
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Kafka producers â†’ `kafka_producer_messages_total{topic, status}`
          - Kafka consumers â†’ `kafka_consumer_messages_total{topic, partition}`
          - Message processing â†’ `kafka_message_duration_seconds{topic, operation}`
          - Error handling â†’ `kafka_errors_total{type, topic, operation}`
          - Consumer lag â†’ `kafka_consumer_lag{topic, partition, group}`
          - Connection health â†’ `kafka_connection_status{broker, state}`
          - Offset commits â†’ `kafka_offset_commits_total{topic, group, status}`

    - path: "**/{redis,df,dragonfly,cache,queue}*/**"
      instructions: |
        **Comprehensive Redis Code Review Checklist:**

        **ğŸ”‘ Key Management & Naming:**
        1. **Key Naming Conventions:**
           - âœ… Use clear, hierarchical key names (e.g., `user:123:profile`, `order:456:items`)
           - âœ… Keep keys concise to save memory space
           - âœ… Use consistent naming patterns across your application
           - âœ… Avoid excessively long key names (>100 characters)
           - âœ… Use colons (`:`) for hierarchical separation, not underscores or dashes

        2. **Key Expiration & TTL:**
           - âœ… Always set appropriate TTL for transient/cache data
           - âœ… Use `EXPIRE` or `PEXPIRE` for automatic cleanup
           - âš ï¸ Never set TTL to 0 (indefinite) for cache data

        **ğŸš€ Performance & Scalability:**
        3. **Avoiding Unbounded Operations:**
           - âœ… **Never use without limits**: `HGETALL`, `LRANGE`, `SMEMBERS`, `ZRANGE`
           - âœ… **Always check size first**: Use `HLEN`, `LLEN`, `SCARD`, `ZCARD`
           - âœ… **Use iterative commands**: `HSCAN`, `SSCAN`, `ZSCAN`, `LSCAN`
           - âœ… **Set reasonable limits**: `LRANGE key 0 99` instead of `LRANGE key 0 -1`
           - âœ… **Implement pagination**: Use `SCAN` with cursor-based iteration

        4. **Blocking Commands (Production Forbidden):**
           - âŒ **Never use in production**: `KEYS`, `FLUSHALL`, `FLUSHDB`
           - âœ… **Use alternatives**: `SCAN` for key discovery, selective deletion
           - âœ… **Implement safely**: Use `DEL` with specific keys, not pattern deletion
           - âœ… **Monitor usage**: Alert on any blocking command execution

        5. **Pipelining & Batching:**
           - âœ… Use pipelining for multiple related operations
           - âœ… Batch commands to reduce network round-trips
           - âœ… Use `MULTI`/`EXEC` for atomic operations when needed

        **ğŸ”Œ Connection & Resource Management:**
        6. **Connection Pooling:**
           - âœ… Configure appropriate pool size based on application load
           - âœ… Set `PoolSize`, `MinIdleConns`, `MaxIdleConns`
           - âœ… Configure `PoolTimeout` for connection acquisition
           - âœ… Monitor pool utilization and connection health
           - âœ… Implement connection health checks

        7. **Timeout Configuration:**
           - âœ… Set `ReadTimeout` for response reading operations
           - âœ… Set `WriteTimeout` for request writing operations
           - âœ… Set `DialTimeout` for connection establishment
           - âœ… Use reasonable timeout values (typically 1-30 seconds)
           - âš ï¸ Never use infinite timeouts

        8. **Resource Cleanup:**
            - âœ… Properly close Redis connections
            - âœ… Implement connection cleanup in application shutdown
            - âœ… Handle connection failures gracefully
            - âœ… Monitor for connection leaks

        **ğŸ“ˆ Error Handling & Resilience:**
        9. **Error Handling Strategies:**
            - âœ… Handle Redis connection failures gracefully
            - âœ… Implement retry logic with exponential backoff
            - âœ… Use circuit breaker patterns for Redis failures
            - âœ… Implement fallback strategies when Redis is unavailable
            - âœ… Log Redis errors with appropriate context

        10. **Fallback Mechanisms:**
            - âœ… Implement local caching when Redis is down
            - âœ… Use database as fallback for critical data
            - âœ… Graceful degradation of non-critical features
            - âœ… Monitor fallback usage and Redis health

        **ğŸ’¾ Data Management & Optimization:**
        11. **Compression & Serialization:**
            - âœ… Use compression for large values (gzip, zstd, lz4)
            - âœ… Choose appropriate serialization format (JSON, MessagePack, Protocol Buffers)
            - âœ… Monitor compression ratios and performance impact
            - âœ… Balance compression vs CPU overhead

        **ğŸ“Š Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - âœ… Track Redis operation latency and throughput
            - âœ… Monitor connection pool utilization
            - âœ… Track error rates and failure patterns
            - âœ… Monitor memory usage and key expiration
            - âœ… Implement health checks for Redis availability

        13. **Logging & Tracing:**
            - âœ… Log Redis operations with appropriate detail
            - âœ… Include correlation IDs for request tracing
            - âœ… Log slow queries and performance issues
            - âœ… Use structured logging with consistent field names


        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Make sure that the redis client is not created for each request
        - âŒ Using `KEYS` command in production code
        - âŒ Unbounded `HGETALL`, `LRANGE`, `SMEMBERS` without size checks
        - âŒ Missing TTL for cache data
        - âŒ No connection pooling or timeout configuration
        - âŒ Hardcoded Redis credentials or connection strings
        - âŒ No error handling for Redis failures
        - âŒ Missing fallback mechanisms for Redis unavailability
        - âŒ No monitoring or health checks implemented
        - âŒ Using `FLUSHALL`/`FLUSHDB` in application code
        - âŒ No compression for large values

        **ğŸ” Review Focus Areas:**
        - Verify key naming conventions and TTL usage
        - Check for unbounded operations and blocking commands
        - Ensure proper connection pooling and timeout configuration
        - Validate security settings and authentication
        - Review error handling and fallback strategies
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Redis operations â†’ `redis_operations_total{operation, status}`
          - Operation latency â†’ `redis_operation_duration_seconds{operation}`
          - Connection usage â†’ `redis_connections_active{state}`
          - Memory usage â†’ `redis_memory_bytes{type}`
          - Key operations â†’ `redis_keys_total{operation, data_type}`
          - Error handling â†’ `redis_errors_total{type, operation}`
          - Cache hits/misses â†’ `redis_cache_hits_total{key_pattern}`

    - path: "**/*{redis*,df*,dragonfly*,cache*,queue*}*"
      instructions: |
        **Comprehensive Redis Code Review Checklist:**

        **ğŸ”‘ Key Management & Naming:**
        1. **Key Naming Conventions:**
           - âœ… Use clear, hierarchical key names (e.g., `user:123:profile`, `order:456:items`)
           - âœ… Keep keys concise to save memory space
           - âœ… Use consistent naming patterns across your application
           - âœ… Avoid excessively long key names (>100 characters)
           - âœ… Use colons (`:`) for hierarchical separation, not underscores or dashes

        2. **Key Expiration & TTL:**
           - âœ… Always set appropriate TTL for transient/cache data
           - âœ… Use `EXPIRE` or `PEXPIRE` for automatic cleanup
           - âš ï¸ Never set TTL to 0 (indefinite) for cache data

        **ğŸš€ Performance & Scalability:**
        3. **Avoiding Unbounded Operations:**
           - âœ… **Never use without limits**: `HGETALL`, `LRANGE`, `SMEMBERS`, `ZRANGE`
           - âœ… **Always check size first**: Use `HLEN`, `LLEN`, `SCARD`, `ZCARD`
           - âœ… **Use iterative commands**: `HSCAN`, `SSCAN`, `ZSCAN`, `LSCAN`
           - âœ… **Set reasonable limits**: `LRANGE key 0 99` instead of `LRANGE key 0 -1`
           - âœ… **Implement pagination**: Use `SCAN` with cursor-based iteration

        4. **Blocking Commands (Production Forbidden):**
           - âŒ **Never use in production**: `KEYS`, `FLUSHALL`, `FLUSHDB`
           - âœ… **Use alternatives**: `SCAN` for key discovery, selective deletion
           - âœ… **Implement safely**: Use `DEL` with specific keys, not pattern deletion
           - âœ… **Monitor usage**: Alert on any blocking command execution

        5. **Pipelining & Batching:**
           - âœ… Use pipelining for multiple related operations
           - âœ… Batch commands to reduce network round-trips
           - âœ… Use `MULTI`/`EXEC` for atomic operations when needed

        **ğŸ”Œ Connection & Resource Management:**
        6. **Connection Pooling:**
           - âœ… Configure appropriate pool size based on application load
           - âœ… Set `PoolSize`, `MinIdleConns`, `MaxIdleConns`
           - âœ… Configure `PoolTimeout` for connection acquisition
           - âœ… Monitor pool utilization and connection health
           - âœ… Implement connection health checks

        7. **Timeout Configuration:**
           - âœ… Set `ReadTimeout` for response reading operations
           - âœ… Set `WriteTimeout` for request writing operations
           - âœ… Set `DialTimeout` for connection establishment
           - âœ… Use reasonable timeout values (typically 1-30 seconds)
           - âš ï¸ Never use infinite timeouts

        8. **Resource Cleanup:**
            - âœ… Properly close Redis connections
            - âœ… Implement connection cleanup in application shutdown
            - âœ… Handle connection failures gracefully
            - âœ… Monitor for connection leaks

        **ğŸ“ˆ Error Handling & Resilience:**
        9. **Error Handling Strategies:**
            - âœ… Handle Redis connection failures gracefully
            - âœ… Implement retry logic with exponential backoff
            - âœ… Use circuit breaker patterns for Redis failures
            - âœ… Implement fallback strategies when Redis is unavailable
            - âœ… Log Redis errors with appropriate context

        10. **Fallback Mechanisms:**
            - âœ… Implement local caching when Redis is down
            - âœ… Use database as fallback for critical data
            - âœ… Graceful degradation of non-critical features
            - âœ… Monitor fallback usage and Redis health

        **ğŸ’¾ Data Management & Optimization:**
        11. **Compression & Serialization:**
            - âœ… Use compression for large values (gzip, zstd, lz4)
            - âœ… Choose appropriate serialization format (JSON, MessagePack, Protocol Buffers)
            - âœ… Monitor compression ratios and performance impact
            - âœ… Balance compression vs CPU overhead

        **ğŸ“Š Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - âœ… Track Redis operation latency and throughput
            - âœ… Monitor connection pool utilization
            - âœ… Track error rates and failure patterns
            - âœ… Monitor memory usage and key expiration
            - âœ… Implement health checks for Redis availability

        13. **Logging & Tracing:**
            - âœ… Log Redis operations with appropriate detail
            - âœ… Include correlation IDs for request tracing
            - âœ… Log slow queries and performance issues
            - âœ… Use structured logging with consistent field names


        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Make sure that the redis client is not created for each request
        - âŒ Using `KEYS` command in production code
        - âŒ Unbounded `HGETALL`, `LRANGE`, `SMEMBERS` without size checks
        - âŒ Missing TTL for cache data
        - âŒ No connection pooling or timeout configuration
        - âŒ Hardcoded Redis credentials or connection strings
        - âŒ No error handling for Redis failures
        - âŒ Missing fallback mechanisms for Redis unavailability
        - âŒ No monitoring or health checks implemented
        - âŒ Using `FLUSHALL`/`FLUSHDB` in application code
        - âŒ No compression for large values

        **ğŸ” Review Focus Areas:**
        - Verify key naming conventions and TTL usage
        - Check for unbounded operations and blocking commands
        - Ensure proper connection pooling and timeout configuration
        - Validate security settings and authentication
        - Review error handling and fallback strategies
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Redis operations â†’ `redis_operations_total{operation, status}`
          - Operation latency â†’ `redis_operation_duration_seconds{operation}`
          - Connection usage â†’ `redis_connections_active{state}`
          - Memory usage â†’ `redis_memory_bytes{type}`
          - Key operations â†’ `redis_keys_total{operation, data_type}`
          - Error handling â†’ `redis_errors_total{type, operation}`
          - Cache hits/misses â†’ `redis_cache_hits_total{key_pattern}`

    - path: "**/{scylladb,scylla}*/**"
      instructions: |
        **Comprehensive ScyllaDB Code Review Checklist:**

        **ğŸ”§ Client Lifecycle & Resource Management:**
        1. **Connection Management:**
           - âœ… Configure appropriate connection pool size and timeouts
           - âœ… Implement graceful connection closing and cleanup
           - âœ… Handle connection failures with exponential backoff
           - âš ï¸ Never create new client connections per request

        2. **Session Management:**
           - âœ… Reuse session instances throughout application lifecycle
           - âœ… Configure session-level timeouts and retry policies
           - âœ… Implement proper session cleanup in application shutdown
           - âœ… Monitor session health and connection status

        **ğŸ“Š Query Performance & Optimization:**
        3. **Prepared Statements:**
           - âœ… Use prepared statements for frequently executed queries
           - âœ… Cache prepared statements at application level
           - âœ… Avoid dynamic query construction to prevent CQL injection
           - âœ… Monitor prepared statement cache hit rates

        4. **Query Timeouts:**
           - âœ… Set explicit timeouts for all queries (typically 5-30 seconds)
           - âœ… Configure different timeouts for reads vs writes
           - âœ… Implement query cancellation for long-running operations
           - âš ï¸ Never use infinite timeouts - can cause resource exhaustion

        5. **Consistency Levels:**
           - âœ… Explicitly set appropriate consistency levels for all operations
           - âœ… **Read Consistency**: `ONE` (fast), `LOCAL_QUORUM` (balanced), `QUORUM` (strong)
           - âœ… **Write Consistency**: `ONE` (fast), `LOCAL_QUORUM` (balanced), `QUORUM` (strong)
           - âœ… Understand trade-offs: higher consistency = lower availability + higher latency
           - âœ… Document consistency level choices with business justification

        **ğŸš€ Performance & Scalability:**
        6. **BYPASS CACHE Optimization:**
           - âœ… Use `BYPASS CACHE` for large range queries that aren't latency-sensitive

        7. **Batch Operations:**
           - âœ… Use batch statements for multiple related operations
           - âœ… Keep batch sizes reasonable (typically 10-100 operations)

        **ğŸ›¡ï¸ Security & Best Practices:**
        8. **Authentication & Authorization:**
           - âœ… Use proper authentication (username/password, certificates)
           - âœ… Use secure credential management (environment variables, not hardcoded)

        9. **Query Security:**
            - âœ… Use parameterized queries to prevent CQL injection

        **ğŸ“ˆ Error Handling & Resilience:**
        10. **Retry Strategies:**
            - âœ… Implement intelligent retry logic with exponential backoff
            - âœ… Use jitter in retry delays to prevent thundering herd
            - âš ï¸ **Critical**: Avoid aggressive retries during database surges
            - âœ… Monitor retry patterns and adjust strategies accordingly

        11. **Error Classification:**
            - âœ… Handle `UnavailableException` for temporary failures
            - âœ… Handle `ReadTimeoutException` and `WriteTimeoutException`
            - âœ… Handle `ConsistencyException` for consistency level violations
            - âœ… Implement circuit breaker patterns for persistent failures


        **ğŸ“Š Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - âœ… Track query latency and throughput
            - âœ… Monitor connection pool utilization

        13. **Logging & Tracing:**
            - âœ… Log slow queries and performance issues
            - âœ… Include correlation IDs for request tracing
            - âœ… Log consistency level violations and retries
            - âœ… Use structured logging with consistent field names

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Creating new ScyllaDB clients per request
        - âŒ Missing query timeouts or infinite timeouts
        - âŒ No retry logic for transient failures
        - âŒ Missing consistency level configuration
        - âŒ Hardcoded credentials or connection strings
        - âŒ No monitoring or metrics implementation
        - âŒ No prepared statement usage for repeated queries
        - âŒ Aggressive retries during database surges
        - âŒ Missing error handling for different exception types

        **ğŸ” Review Focus Areas:**
        - Verify client lifecycle management and connection pooling
        - Check query timeout configurations and consistency levels
        - Ensure proper error handling and retry strategies
        - Validate security configurations and authentication
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - ScyllaDB queries â†’ `scylla_queries_total{operation, consistency, status}`
          - Query latency â†’ `scylla_query_duration_seconds{operation, consistency}`
          - Connection usage â†’ `scylla_connections_active{state}`
          - Consistency violations â†’ `scylla_consistency_violations_total{operation}`
          - Retry attempts â†’ `scylla_retries_total{operation, reason}`
          - Cache operations â†’ `scylla_cache_operations_total{operation, status}`

    - path: "**/*{scylladb*,scylla*}*"
      instructions: |
        **Comprehensive ScyllaDB Code Review Checklist:**

        **ğŸ”§ Client Lifecycle & Resource Management:**
        1. **Connection Management:**
           - âœ… Configure appropriate connection pool size and timeouts
           - âœ… Implement graceful connection closing and cleanup
           - âœ… Handle connection failures with exponential backoff
           - âš ï¸ Never create new client connections per request

        2. **Session Management:**
           - âœ… Reuse session instances throughout application lifecycle
           - âœ… Configure session-level timeouts and retry policies
           - âœ… Implement proper session cleanup in application shutdown
           - âœ… Monitor session health and connection status

        **ğŸ“Š Query Performance & Optimization:**
        3. **Prepared Statements:**
           - âœ… Use prepared statements for frequently executed queries
           - âœ… Cache prepared statements at application level
           - âœ… Avoid dynamic query construction to prevent CQL injection
           - âœ… Monitor prepared statement cache hit rates

        4. **Query Timeouts:**
           - âœ… Set explicit timeouts for all queries (typically 5-30 seconds)
           - âœ… Configure different timeouts for reads vs writes
           - âœ… Implement query cancellation for long-running operations
           - âš ï¸ Never use infinite timeouts - can cause resource exhaustion

        5. **Consistency Levels:**
           - âœ… Explicitly set appropriate consistency levels for all operations
           - âœ… **Read Consistency**: `ONE` (fast), `LOCAL_QUORUM` (balanced), `QUORUM` (strong)
           - âœ… **Write Consistency**: `ONE` (fast), `LOCAL_QUORUM` (balanced), `QUORUM` (strong)
           - âœ… Understand trade-offs: higher consistency = lower availability + higher latency
           - âœ… Document consistency level choices with business justification

        **ğŸš€ Performance & Scalability:**
        6. **BYPASS CACHE Optimization:**
           - âœ… Use `BYPASS CACHE` for large range queries that aren't latency-sensitive

        7. **Batch Operations:**
           - âœ… Use batch statements for multiple related operations
           - âœ… Keep batch sizes reasonable (typically 10-100 operations)

        **ğŸ›¡ï¸ Security & Best Practices:**
        8. **Authentication & Authorization:**
           - âœ… Use proper authentication (username/password, certificates)
           - âœ… Use secure credential management (environment variables, not hardcoded)

        9. **Query Security:**
            - âœ… Use parameterized queries to prevent CQL injection

        **ğŸ“ˆ Error Handling & Resilience:**
        10. **Retry Strategies:**
            - âœ… Implement intelligent retry logic with exponential backoff
            - âœ… Use jitter in retry delays to prevent thundering herd
            - âš ï¸ **Critical**: Avoid aggressive retries during database surges
            - âœ… Monitor retry patterns and adjust strategies accordingly

        11. **Error Classification:**
            - âœ… Handle `UnavailableException` for temporary failures
            - âœ… Handle `ReadTimeoutException` and `WriteTimeoutException`
            - âœ… Handle `ConsistencyException` for consistency level violations
            - âœ… Implement circuit breaker patterns for persistent failures


        **ğŸ“Š Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - âœ… Track query latency and throughput
            - âœ… Monitor connection pool utilization

        13. **Logging & Tracing:**
            - âœ… Log slow queries and performance issues
            - âœ… Include correlation IDs for request tracing
            - âœ… Log consistency level violations and retries
            - âœ… Use structured logging with consistent field names

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Creating new ScyllaDB clients per request
        - âŒ Missing query timeouts or infinite timeouts
        - âŒ No retry logic for transient failures
        - âŒ Missing consistency level configuration
        - âŒ Hardcoded credentials or connection strings
        - âŒ No monitoring or metrics implementation
        - âŒ No prepared statement usage for repeated queries
        - âŒ Aggressive retries during database surges
        - âŒ Missing error handling for different exception types

        **ğŸ” Review Focus Areas:**
        - Verify client lifecycle management and connection pooling
        - Check query timeout configurations and consistency levels
        - Ensure proper error handling and retry strategies
        - Validate security configurations and authentication
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - ScyllaDB queries â†’ `scylla_queries_total{operation, consistency, status}`
          - Query latency â†’ `scylla_query_duration_seconds{operation, consistency}`
          - Connection usage â†’ `scylla_connections_active{state}`
          - Consistency violations â†’ `scylla_consistency_violations_total{operation}`
          - Retry attempts â†’ `scylla_retries_total{operation, reason}`
          - Cache operations â†’ `scylla_cache_operations_total{operation, status}`

    - path: "**/{spanner}*/**"
      instructions: |
        **Comprehensive Google Spanner Code Review Checklist:**

        **ğŸ”§ Client Lifecycle & Resource Management:**
        1. **Connection Management:**
           - âœ… Configure appropriate connection pool size and timeouts
           - âœ… Implement graceful client cleanup and shutdown
           - âœ… Handle connection failures with exponential backoff
           - âš ï¸ Never create new Spanner clients per request

        2. **Session Management:**
           - âœ… Reuse session instances throughout application lifecycle
           - âœ… Configure session-level timeouts and retry policies
           - âœ… Implement proper session cleanup in application shutdown

        **ğŸ“Š Transaction Management:**
        3. **Transaction Types & Usage:**
           - âœ… Use `ReadOnlyTransaction` for read-only operations
           - âœ… Use `ReadWriteTransaction` for data modifications

        4. **Transaction Best Practices:**
           - âœ… **Error Handling**: Implement proper rollback and retry logic
           - âœ… **Monitoring**: Track transaction duration and failure rates

        **ğŸš€ Performance & Query Optimization:**
        5. **Query Timeouts:**
           - âœ… Set explicit timeouts for all Spanner queries (typically 5-60 seconds). This is during client initialization
           - âœ… Configure different timeouts for reads vs writes
           - âœ… Implement query cancellation for long-running operations
           - âœ… Use `StatementTimeout` for individual query timeouts
           - âš ï¸ Never use infinite timeouts - can cause resource exhaustion


        6. **Query Priority Management:**
           - âœ… Set appropriate query priorities: `HIGH`, `MEDIUM`, or `LOW`
           - âœ… **HIGH Priority**: Critical user-facing queries, real-time operations
           - âœ… **MEDIUM Priority**: Standard business operations, batch processing
           - âœ… **LOW Priority**: Background jobs, analytics, non-critical operations
           - âœ… Balance priority levels to manage resource contention effectively

        7. **FORCE_INDEX Usage:**
           - âœ… Use `FORCE_INDEX` when you need Spanner to use a specific index
           - âœ… **Use Cases**: Query optimization, performance testing, index validation
           - âœ… **Caution**: Only use when you're confident about index choice
           - âœ… **Monitoring**: Track query performance with forced vs automatic index selection
           - âœ… **Documentation**: Document why specific indexes are forced

        8. **Query Security:**
            - âœ… Use parameterized queries to prevent SQL injection
            - âœ… Use prepared statements for repeated queries

        **ğŸ“ˆ Error Handling & Resilience:**
        9. **Error Classification & Handling:**
            - âœ… Handle `AbortedException` for transaction conflicts
            - âœ… Handle `DeadlineExceededException` for timeout scenarios
            - âœ… Handle `ResourceExhaustedException` for quota limits
            - âœ… Handle `FailedPreconditionException` for invalid operations

        10. **Retry Strategies:**
            - âœ… Implement intelligent retry logic with exponential backoff
            - âœ… Use jitter in retry delays to prevent thundering herd
            - âœ… Distinguish between retryable and non-retryable errors
            - âœ… Implement backoff strategies for different error types
            - âœ… Monitor retry patterns and adjust strategies accordingly

        **ğŸ“Š Observability & Monitoring:**
        11. **Metrics & Monitoring:**
            - âœ… Track query latency and throughput
            - âœ… Monitor transaction success rates and durations
            - âœ… Monitor connection pool utilization


        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Creating new Spanner clients per request
        - âŒ Missing query timeouts or infinite timeouts
        - âŒ Long-running transactions (>10 seconds)
        - âŒ No retry logic for transient failures
        - âŒ Missing query priority configuration
        - âŒ Hardcoded credentials or connection strings
        - âŒ No monitoring or metrics implementation
        - âŒ Missing error handling for different exception types
        - âŒ No transaction conflict resolution
        - âŒ **SELECT ***: Always specify required columns explicitly

        **ğŸ” Review Focus Areas:**
        - Verify client lifecycle management and connection pooling
        - Check transaction design and duration optimization
        - Ensure proper error handling and retry strategies
        - Validate security configurations and authentication
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Spanner queries â†’ `spanner_queries_total{operation, priority, status}`
          - Query latency â†’ `spanner_query_duration_seconds{operation, priority}`
          - Transaction metrics â†’ `spanner_transactions_total{type, status}`
          - Connection usage â†’ `spanner_connections_active{state}`
          - Index operations â†’ `spanner_index_operations_total{operation, index_name}`
          - Error handling â†’ `spanner_errors_total{type, operation}`
          - Retry attempts â†’ `spanner_retries_total{operation, reason}`

    - path: "**/*{spanner*}*"
      instructions: |
        **Comprehensive Google Spanner Code Review Checklist:**

        **ğŸ”§ Client Lifecycle & Resource Management:**
        1. **Connection Management:**
           - âœ… Configure appropriate connection pool size and timeouts
           - âœ… Implement graceful client cleanup and shutdown
           - âœ… Handle connection failures with exponential backoff
           - âš ï¸ Never create new Spanner clients per request

        2. **Session Management:**
           - âœ… Reuse session instances throughout application lifecycle
           - âœ… Configure session-level timeouts and retry policies
           - âœ… Implement proper session cleanup in application shutdown

        **ğŸ“Š Transaction Management:**
        3. **Transaction Types & Usage:**
           - âœ… Use `ReadOnlyTransaction` for read-only operations
           - âœ… Use `ReadWriteTransaction` for data modifications

        4. **Transaction Best Practices:**
           - âœ… **Error Handling**: Implement proper rollback and retry logic
           - âœ… **Monitoring**: Track transaction duration and failure rates

        **ğŸš€ Performance & Query Optimization:**
        5. **Query Timeouts:**
           - âœ… Set explicit timeouts for all Spanner queries (typically 5-60 seconds). This is during client initialization
           - âœ… Configure different timeouts for reads vs writes
           - âœ… Implement query cancellation for long-running operations
           - âœ… Use `StatementTimeout` for individual query timeouts
           - âš ï¸ Never use infinite timeouts - can cause resource exhaustion


        6. **Query Priority Management:**
           - âœ… Set appropriate query priorities: `HIGH`, `MEDIUM`, or `LOW`
           - âœ… **HIGH Priority**: Critical user-facing queries, real-time operations
           - âœ… **MEDIUM Priority**: Standard business operations, batch processing
           - âœ… **LOW Priority**: Background jobs, analytics, non-critical operations
           - âœ… Balance priority levels to manage resource contention effectively

        7. **FORCE_INDEX Usage:**
           - âœ… Use `FORCE_INDEX` when you need Spanner to use a specific index
           - âœ… **Use Cases**: Query optimization, performance testing, index validation
           - âœ… **Caution**: Only use when you're confident about index choice
           - âœ… **Monitoring**: Track query performance with forced vs automatic index selection
           - âœ… **Documentation**: Document why specific indexes are forced

        8. **Query Security:**
            - âœ… Use parameterized queries to prevent SQL injection
            - âœ… Use prepared statements for repeated queries

        **ğŸ“ˆ Error Handling & Resilience:**
        9. **Error Classification & Handling:**
            - âœ… Handle `AbortedException` for transaction conflicts
            - âœ… Handle `DeadlineExceededException` for timeout scenarios
            - âœ… Handle `ResourceExhaustedException` for quota limits
            - âœ… Handle `FailedPreconditionException` for invalid operations

        10. **Retry Strategies:**
            - âœ… Implement intelligent retry logic with exponential backoff
            - âœ… Use jitter in retry delays to prevent thundering herd
            - âœ… Distinguish between retryable and non-retryable errors
            - âœ… Implement backoff strategies for different error types
            - âœ… Monitor retry patterns and adjust strategies accordingly

        **ğŸ“Š Observability & Monitoring:**
        11. **Metrics & Monitoring:**
            - âœ… Track query latency and throughput
            - âœ… Monitor transaction success rates and durations
            - âœ… Monitor connection pool utilization


        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Creating new Spanner clients per request
        - âŒ Missing query timeouts or infinite timeouts
        - âŒ Long-running transactions (>10 seconds)
        - âŒ No retry logic for transient failures
        - âŒ Missing query priority configuration
        - âŒ Hardcoded credentials or connection strings
        - âŒ No monitoring or metrics implementation
        - âŒ Missing error handling for different exception types
        - âŒ No transaction conflict resolution
        - âŒ **SELECT ***: Always specify required columns explicitly

        **ğŸ” Review Focus Areas:**
        - Verify client lifecycle management and connection pooling
        - Check transaction design and duration optimization
        - Ensure proper error handling and retry strategies
        - Validate security configurations and authentication
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Spanner queries â†’ `spanner_queries_total{operation, priority, status}`
          - Query latency â†’ `spanner_query_duration_seconds{operation, priority}`
          - Transaction metrics â†’ `spanner_transactions_total{type, status}`
          - Connection usage â†’ `spanner_connections_active{state}`
          - Index operations â†’ `spanner_index_operations_total{operation, index_name}`
          - Error handling â†’ `spanner_errors_total{type, operation}`
          - Retry attempts â†’ `spanner_retries_total{operation, reason}`

    - path: "**/{postgres,cloudsql,db,database,sql,psql}*/**"
      instructions: |
        **Comprehensive PostgreSQL/CloudSQL Code Review Checklist:**

        **ğŸ›¡ï¸ Security & Injection Prevention:**
        1. **SQL Injection Prevention:**
           - âœ… **Always use parameterized queries** to prevent SQL injection
           - âœ… Use prepared statements for repeated queries
           - âœ… Never concatenate user input directly into SQL strings
           - âœ… Use ORM query builders when possible for additional safety
           - âš ï¸ **Critical**: Flag any string concatenation in SQL queries

        **ğŸš€ Performance & Query Optimization:**
        2. **Query Performance Analysis:**
           - âœ… **N+1 Query Detection**: Look for loops that execute database queries
           - âœ… **Batching**: Use `IN` clauses or batch operations instead of individual queries

        3. **Performance Anti-Patterns:**
           - âŒ **FULL SCAN**: Avoid table scans on large tables
           - âŒ **CARTESIAN JOIN**: Never use cross joins without explicit WHERE conditions
           - âŒ **SELECT ***: Always specify required columns explicitly
           - âŒ **Subqueries in SELECT**: Use JOINs when possible
           - âŒ **Functions on indexed columns**: Avoid applying functions to indexed columns


        **ğŸ”Œ Connection & Resource Management:**
        4. **Connection Management:**
           - âœ… Use connection pooling (PgBouncer, application-level pools)
           - âœ… Configure appropriate pool size based on application load
           - âœ… Set connection timeouts and idle connection limits
           - âœ… Implement proper connection cleanup and error handling
           - âœ… Monitor connection pool utilization and health

        5. **Resource Cleanup:**
           - âœ… Always close database connections after use
           - âœ… Use try-with-resources or defer statements for cleanup
           - âœ… Implement proper error handling with connection cleanup
           - âœ… Monitor for connection leaks and resource exhaustion
           - âœ… Handle connection failures gracefully with retry logic

        **ğŸ“Š Transaction Management:**
        6. **Transaction Best Practices:**
           - âœ… **Explicit Transactions**: Use `BEGIN`, `COMMIT`, and `ROLLBACK` explicitly
           - âœ… **Short Transactions**: Keep transactions as short as possible
           - âœ… **Error Handling**: Implement proper rollback on errors
           - âœ… **Isolation Levels**: Understand and use appropriate isolation levels
           - âœ… **Deadlock Prevention**: Order operations consistently to avoid deadlocks
           - âœ… **Monitoring**: Track transaction duration and failure rates

        7. **Transaction Patterns:**
           - âœ… **Read-Only Transactions**: Use for consistent reads across multiple queries
           - âœ… **Write Transactions**: Group related modifications in single transactions
           - âœ… **Nested Transactions**: Use savepoints for complex transaction logic
           - âœ… **Distributed Transactions**: Consider 2PC for multi-database operations


        **ğŸ“ˆ Error Handling & Resilience:**
        8. **Error Handling Strategies:**
            - âœ… **Connection Errors**: Handle connection failures with retry logic
            - âœ… **Query Errors**: Handle syntax and constraint violation errors
            - âœ… **Transaction Errors**: Implement proper rollback and retry logic
            - âœ… **Deadlock Handling**: Implement exponential backoff for deadlock retries
            - âœ… **Logging**: Log all database errors with context and stack traces

        9. **Retry Logic:**
            - âœ… Implement exponential backoff with jitter for transient errors
            - âœ… Set maximum retry attempts to prevent infinite loops
            - âœ… Use circuit breaker patterns for persistent failures
            - âœ… Monitor retry patterns and adjust strategies accordingly

        **ğŸ” Query Clarity & Maintainability:**
        10. **Query Readability:**
            - âœ… **Aliases**: Use meaningful table and column aliases
            - âœ… **Formatting**: Format SQL queries for readability
            - âœ… **Comments**: Add comments for complex queries
            - âœ… **Consistency**: Use consistent naming conventions
            - âœ… **Modularity**: Break complex queries into smaller, readable parts

        11. **Query Optimization:**
            - âœ… **LIMIT**: Always use LIMIT for potentially large result sets
            - âœ… **OFFSET**: Use cursor-based pagination instead of OFFSET for large datasets
            - âœ… **Window Functions**: Use window functions for ranking and aggregation
            - âœ… **CTEs**: Use Common Table Expressions for complex queries
            - âœ… **Materialized Views**: Consider materialized views for expensive aggregations


        **ğŸ“Š Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - âœ… Track query latency and throughput
            - âœ… Monitor connection pool utilization
            - âœ… Track slow query patterns and execution plans
            - âœ… Monitor index usage and performance impact
            - âœ… Track transaction success rates and durations
            - âœ… Implement health checks for database availability

        13. **Logging & Tracing:**
            - âœ… Log slow queries and performance issues
            - âœ… Include correlation IDs for request tracing
            - âœ… Log transaction conflicts and retry attempts
            - âœ… Use structured logging with consistent field names
            - âœ… Log query execution plans for optimization

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ String concatenation in SQL queries (SQL injection risk)
        - âŒ Missing parameterized queries or prepared statements
        - âŒ N+1 query patterns in loops
        - âŒ Missing indexes on frequently queried columns
        - âŒ Using `SELECT *` instead of specific columns
        - âŒ Missing transaction boundaries for related operations
        - âŒ No connection pooling or timeout configuration
        - âŒ Hardcoded database credentials
        - âŒ No error handling for database failures
        - âŒ Missing LIMIT clauses on potentially large result sets

        **ğŸ” Review Focus Areas:**
        - Verify SQL injection prevention and parameterized queries
        - Check for N+1 query patterns and performance issues
        - Ensure proper connection management and pooling
        - Validate transaction design and error handling
        - Review index usage and query optimization
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Database queries â†’ `postgres_queries_total{operation, table, status}`
          - Query latency â†’ `postgres_query_duration_seconds{operation, table}`
          - Connection usage â†’ `postgres_connections_active{state}`
          - Transaction metrics â†’ `postgres_transactions_total{type, status}`
          - Index operations â†’ `postgres_index_operations_total{operation, index_name}`
          - Error handling â†’ `postgres_errors_total{type, operation}`
          - Connection pool â†’ `postgres_connection_pool_size{state}`

    - path: "**/*{postgres*,cloudsql*,db*,database*,sql*,psql*}*"
      instructions: |
        **Comprehensive PostgreSQL/CloudSQL Code Review Checklist:**

        **ğŸ›¡ï¸ Security & Injection Prevention:**
        1. **SQL Injection Prevention:**
           - âœ… **Always use parameterized queries** to prevent SQL injection
           - âœ… Use prepared statements for repeated queries
           - âœ… Never concatenate user input directly into SQL strings
           - âœ… Use ORM query builders when possible for additional safety
           - âš ï¸ **Critical**: Flag any string concatenation in SQL queries

        **ğŸš€ Performance & Query Optimization:**
        2. **Query Performance Analysis:**
           - âœ… **N+1 Query Detection**: Look for loops that execute database queries
           - âœ… **Batching**: Use `IN` clauses or batch operations instead of individual queries

        3. **Performance Anti-Patterns:**
           - âŒ **FULL SCAN**: Avoid table scans on large tables
           - âŒ **CARTESIAN JOIN**: Never use cross joins without explicit WHERE conditions
           - âŒ **SELECT ***: Always specify required columns explicitly
           - âŒ **Subqueries in SELECT**: Use JOINs when possible
           - âŒ **Functions on indexed columns**: Avoid applying functions to indexed columns


        **ğŸ”Œ Connection & Resource Management:**
        4. **Connection Management:**
           - âœ… Use connection pooling (PgBouncer, application-level pools)
           - âœ… Configure appropriate pool size based on application load
           - âœ… Set connection timeouts and idle connection limits
           - âœ… Implement proper connection cleanup and error handling
           - âœ… Monitor connection pool utilization and health

        5. **Resource Cleanup:**
           - âœ… Always close database connections after use
           - âœ… Use try-with-resources or defer statements for cleanup
           - âœ… Implement proper error handling with connection cleanup
           - âœ… Monitor for connection leaks and resource exhaustion
           - âœ… Handle connection failures gracefully with retry logic

        **ğŸ“Š Transaction Management:**
        6. **Transaction Best Practices:**
           - âœ… **Explicit Transactions**: Use `BEGIN`, `COMMIT`, and `ROLLBACK` explicitly
           - âœ… **Short Transactions**: Keep transactions as short as possible
           - âœ… **Error Handling**: Implement proper rollback on errors
           - âœ… **Isolation Levels**: Understand and use appropriate isolation levels
           - âœ… **Deadlock Prevention**: Order operations consistently to avoid deadlocks
           - âœ… **Monitoring**: Track transaction duration and failure rates

        7. **Transaction Patterns:**
           - âœ… **Read-Only Transactions**: Use for consistent reads across multiple queries
           - âœ… **Write Transactions**: Group related modifications in single transactions
           - âœ… **Nested Transactions**: Use savepoints for complex transaction logic
           - âœ… **Distributed Transactions**: Consider 2PC for multi-database operations


        **ğŸ“ˆ Error Handling & Resilience:**
        8. **Error Handling Strategies:**
            - âœ… **Connection Errors**: Handle connection failures with retry logic
            - âœ… **Query Errors**: Handle syntax and constraint violation errors
            - âœ… **Transaction Errors**: Implement proper rollback and retry logic
            - âœ… **Deadlock Handling**: Implement exponential backoff for deadlock retries
            - âœ… **Logging**: Log all database errors with context and stack traces

        9. **Retry Logic:**
            - âœ… Implement exponential backoff with jitter for transient errors
            - âœ… Set maximum retry attempts to prevent infinite loops
            - âœ… Use circuit breaker patterns for persistent failures
            - âœ… Monitor retry patterns and adjust strategies accordingly

        **ğŸ” Query Clarity & Maintainability:**
        10. **Query Readability:**
            - âœ… **Aliases**: Use meaningful table and column aliases
            - âœ… **Formatting**: Format SQL queries for readability
            - âœ… **Comments**: Add comments for complex queries
            - âœ… **Consistency**: Use consistent naming conventions
            - âœ… **Modularity**: Break complex queries into smaller, readable parts

        11. **Query Optimization:**
            - âœ… **LIMIT**: Always use LIMIT for potentially large result sets
            - âœ… **OFFSET**: Use cursor-based pagination instead of OFFSET for large datasets
            - âœ… **Window Functions**: Use window functions for ranking and aggregation
            - âœ… **CTEs**: Use Common Table Expressions for complex queries
            - âœ… **Materialized Views**: Consider materialized views for expensive aggregations


        **ğŸ“Š Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - âœ… Track query latency and throughput
            - âœ… Monitor connection pool utilization
            - âœ… Track slow query patterns and execution plans
            - âœ… Monitor index usage and performance impact
            - âœ… Track transaction success rates and durations
            - âœ… Implement health checks for database availability

        13. **Logging & Tracing:**
            - âœ… Log slow queries and performance issues
            - âœ… Include correlation IDs for request tracing
            - âœ… Log transaction conflicts and retry attempts
            - âœ… Use structured logging with consistent field names
            - âœ… Log query execution plans for optimization

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ String concatenation in SQL queries (SQL injection risk)
        - âŒ Missing parameterized queries or prepared statements
        - âŒ N+1 query patterns in loops
        - âŒ Missing indexes on frequently queried columns
        - âŒ Using `SELECT *` instead of specific columns
        - âŒ Missing transaction boundaries for related operations
        - âŒ No connection pooling or timeout configuration
        - âŒ Hardcoded database credentials
        - âŒ No error handling for database failures
        - âŒ Missing LIMIT clauses on potentially large result sets

        **ğŸ” Review Focus Areas:**
        - Verify SQL injection prevention and parameterized queries
        - Check for N+1 query patterns and performance issues
        - Ensure proper connection management and pooling
        - Validate transaction design and error handling
        - Review index usage and query optimization
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Database queries â†’ `postgres_queries_total{operation, table, status}`
          - Query latency â†’ `postgres_query_duration_seconds{operation, table}`
          - Connection usage â†’ `postgres_connections_active{state}`
          - Transaction metrics â†’ `postgres_transactions_total{type, status}`
          - Index operations â†’ `postgres_index_operations_total{operation, index_name}`
          - Error handling â†’ `postgres_errors_total{type, operation}`
          - Connection pool â†’ `postgres_connection_pool_size{state}`

    - path: "**/{temporal,worker,workflow,task,activit}*/**"
      instructions: |
        **Comprehensive Temporal Code Review Checklist:**

        **ğŸ”’ Workflow Determinism (Critical):**
        1. **Deterministic Operations:**
           - âœ… **No System Time**: Never use `System.currentTimeMillis()`, `new Date()`, or similar
           - âœ… **No Random Numbers**: Never use `Math.random()`, `Random.nextInt()`, or similar
           - âœ… **No UUID Generation**: Never use `UUID.randomUUID()` or similar
           - âœ… **Use Temporal APIs**: Use `workflow.now()`, `workflow.randomUUID()`, `workflow.sideEffect()`
           - âš ï¸ **Critical**: Any non-deterministic operation will cause workflow replay failures

        2. **Side Effect Isolation:**
           - âœ… **No Direct I/O**: Never make database calls, network requests, or file system access
           - âœ… **No External Services**: Never call external APIs or services directly
           - âœ… **Delegate to Activities**: All side effects must be in Activities, not Workflows
           - âœ… **Pure Functions**: Workflows should be pure, deterministic functions

        3. **State Management:**
           - âœ… **No Global State**: Never use static variables or global mutable state
           - âœ… **No Concurrent Access**: Avoid concurrent data structures unless managed by Temporal
           - âœ… **Immutable Data**: Use immutable data structures when possible
           - âœ… **Workflow State**: Store state in workflow variables, not external storage

        **ğŸ“‹ Activity Design & Implementation:**
        4. **Activity Idempotency:**
           - âœ… **Always Idempotent**: Design activities to be safely retryable
           - âœ… **Idempotency Keys**: Use unique keys for operations with side effects
           - âœ… **State Checks**: Check current state before performing operations
           - âœ… **Compensation Logic**: Implement rollback mechanisms for failed operations
           - âœ… **No Side Effects**: Activities should be safe to execute multiple times

        5. **Activity Error Handling:**
           - âœ… **Retry Policies**: Configure appropriate retry policies for different error types
           - âœ… **Error Classification**: Distinguish between retryable and non-retryable errors
           - âœ… **Timeout Configuration**: Set appropriate `StartToCloseTimeout` values
           - âœ… **Heartbeating**: Implement heartbeating for long-running activities
           - âœ… **Circuit Breakers**: Use circuit breakers for external service calls

        6. **Activity Timeouts:**
           - âœ… **StartToCloseTimeout**: Maximum time for activity execution
           - âœ… **ScheduleToStartTimeout**: Maximum time to wait for worker assignment
           - âœ… **HeartbeatTimeout**: Maximum time between heartbeats
           - âœ… **ScheduleToCloseTimeout**: Maximum time from scheduling to completion
           - âœ… **Retry Policies**: Configure retry delays and maximum attempts

        **âš™ï¸ Worker Configuration & Management:**
        7. **Worker Concurrency:**
           - âœ… **Activity Concurrency**: Set `MaxConcurrentActivityExecutionSize` appropriately
           - âœ… **Workflow Concurrency**: Set `MaxConcurrentWorkflowTaskExecutionSize`
           - âœ… **Task Polling**: Configure `MaxConcurrentActivityTaskPollers`
           - âœ… **Workflow Polling**: Configure `MaxConcurrentWorkflowTaskPollers`
           - âœ… **Resource Limits**: Balance concurrency with available system resources

        8. **Worker Lifecycle:**
           - âœ… **Graceful Shutdown**: Implement proper shutdown procedures
           - âœ… **Health Checks**: Monitor worker health and availability
           - âœ… **Connection Management**: Handle Temporal service connection failures
           - âœ… **Task Processing**: Ensure tasks are processed efficiently
           - âœ… **Error Recovery**: Implement worker-level error recovery mechanisms

        **ğŸ”„ Workflow Orchestration:**
        9. **Workflow Structure:**
           - âœ… **Single Responsibility**: Each workflow should have one clear purpose
           - âœ… **Granular Activities**: Break complex operations into smaller activities
           - âœ… **Error Propagation**: Properly handle and propagate errors from activities
           - âœ… **Compensation Logic**: Implement rollback for failed workflow steps
           - âœ… **State Management**: Use workflow variables for state, not external storage


        **ğŸ“Š Error Handling & Resilience:**
        10. **Workflow Error Handling:**
            - âœ… **Try-Catch Blocks**: Wrap activity calls in proper error handling
            - âœ… **Retry Logic**: Implement workflow-level retry mechanisms
            - âœ… **Compensation**: Rollback completed steps on failures
            - âœ… **Error Propagation**: Return meaningful error information
            - âœ… **Logging**: Log errors with appropriate context and correlation IDs

        11. **Retry Strategies:**
            - âœ… **Exponential Backoff**: Use increasing delays between retries
            - âœ… **Jitter**: Add randomness to retry delays to prevent thundering herd
            - âœ… **Maximum Attempts**: Set reasonable limits on retry attempts
            - âœ… **Error Classification**: Different retry strategies for different error types
            - âœ… **Monitoring**: Track retry patterns and success rates



        **ğŸ“ˆ Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - âœ… **Workflow Metrics**: Track workflow execution times and success rates
            - âœ… **Activity Metrics**: Monitor activity performance and error rates
            - âœ… **Worker Metrics**: Track worker health and task processing rates
            - âœ… **Retry Metrics**: Monitor retry patterns and success rates
            - âœ… **Resource Usage**: Monitor memory, CPU, and connection usage

        13. **Logging & Tracing:**
            - âœ… **Structured Logging**: Use consistent log formats and field names
            - âœ… **Correlation IDs**: Include workflow and activity IDs in all logs
            - âœ… **Context Information**: Log relevant workflow state and parameters
            - âœ… **Error Details**: Include full error context and stack traces
            - âœ… **Performance Logging**: Log slow operations and bottlenecks

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Using system time or random numbers in workflows
        - âŒ Making direct I/O calls from workflows
        - âŒ Using global mutable state in workflows
        - âŒ Non-idempotent activities without idempotency keys
        - âŒ Missing timeout configurations for activities
        - âŒ No error handling or retry logic
        - âŒ Missing heartbeating for long-running activities
        - âŒ No monitoring or metrics implementation
        - âŒ Hardcoded retry policies or timeout values
        - âŒ Missing compensation logic for failed operations

        **ğŸ” Review Focus Areas:**
        - Verify workflow determinism and no side effects
        - Check activity idempotency and error handling
        - Ensure proper worker configuration and concurrency
        - Validate timeout and retry policy configurations
        - Review error handling and compensation logic
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Workflow execution â†’ `temporal_workflows_total{workflow_type, status}`
          - Workflow duration â†’ `temporal_workflow_duration_seconds{workflow_type}`
          - Activity execution â†’ `temporal_activities_total{activity_type, status}`
          - Activity duration â†’ `temporal_activity_duration_seconds{activity_type}`
          - Worker metrics â†’ `temporal_worker_tasks_total{worker_id, status}`
          - Retry attempts â†’ `temporal_retries_total{operation_type, reason}`
          - Error handling â†’ `temporal_errors_total{type, operation}`
          - Timeout occurrences â†’ `temporal_timeouts_total{type, operation}`
    - path: "**/*{temporal*,worker*,workflow*,task*,activit*}*"
      instructions: |
        **Comprehensive Temporal Code Review Checklist:**

        **ğŸ”’ Workflow Determinism (Critical):**
        1. **Deterministic Operations:**
           - âœ… **No System Time**: Never use `System.currentTimeMillis()`, `new Date()`, or similar
           - âœ… **No Random Numbers**: Never use `Math.random()`, `Random.nextInt()`, or similar
           - âœ… **No UUID Generation**: Never use `UUID.randomUUID()` or similar
           - âœ… **Use Temporal APIs**: Use `workflow.now()`, `workflow.randomUUID()`, `workflow.sideEffect()`
           - âš ï¸ **Critical**: Any non-deterministic operation will cause workflow replay failures

        2. **Side Effect Isolation:**
           - âœ… **No Direct I/O**: Never make database calls, network requests, or file system access
           - âœ… **No External Services**: Never call external APIs or services directly
           - âœ… **Delegate to Activities**: All side effects must be in Activities, not Workflows
           - âœ… **Pure Functions**: Workflows should be pure, deterministic functions

        3. **State Management:**
           - âœ… **No Global State**: Never use static variables or global mutable state
           - âœ… **No Concurrent Access**: Avoid concurrent data structures unless managed by Temporal
           - âœ… **Immutable Data**: Use immutable data structures when possible
           - âœ… **Workflow State**: Store state in workflow variables, not external storage

        **ğŸ“‹ Activity Design & Implementation:**
        4. **Activity Idempotency:**
           - âœ… **Always Idempotent**: Design activities to be safely retryable
           - âœ… **Idempotency Keys**: Use unique keys for operations with side effects
           - âœ… **State Checks**: Check current state before performing operations
           - âœ… **Compensation Logic**: Implement rollback mechanisms for failed operations
           - âœ… **No Side Effects**: Activities should be safe to execute multiple times

        5. **Activity Error Handling:**
           - âœ… **Retry Policies**: Configure appropriate retry policies for different error types
           - âœ… **Error Classification**: Distinguish between retryable and non-retryable errors
           - âœ… **Timeout Configuration**: Set appropriate `StartToCloseTimeout` values
           - âœ… **Heartbeating**: Implement heartbeating for long-running activities
           - âœ… **Circuit Breakers**: Use circuit breakers for external service calls

        6. **Activity Timeouts:**
           - âœ… **StartToCloseTimeout**: Maximum time for activity execution
           - âœ… **ScheduleToStartTimeout**: Maximum time to wait for worker assignment
           - âœ… **HeartbeatTimeout**: Maximum time between heartbeats
           - âœ… **ScheduleToCloseTimeout**: Maximum time from scheduling to completion
           - âœ… **Retry Policies**: Configure retry delays and maximum attempts

        **âš™ï¸ Worker Configuration & Management:**
        7. **Worker Concurrency:**
           - âœ… **Activity Concurrency**: Set `MaxConcurrentActivityExecutionSize` appropriately
           - âœ… **Workflow Concurrency**: Set `MaxConcurrentWorkflowTaskExecutionSize`
           - âœ… **Task Polling**: Configure `MaxConcurrentActivityTaskPollers`
           - âœ… **Workflow Polling**: Configure `MaxConcurrentWorkflowTaskPollers`
           - âœ… **Resource Limits**: Balance concurrency with available system resources

        8. **Worker Lifecycle:**
           - âœ… **Graceful Shutdown**: Implement proper shutdown procedures
           - âœ… **Health Checks**: Monitor worker health and availability
           - âœ… **Connection Management**: Handle Temporal service connection failures
           - âœ… **Task Processing**: Ensure tasks are processed efficiently
           - âœ… **Error Recovery**: Implement worker-level error recovery mechanisms

        **ğŸ”„ Workflow Orchestration:**
        9. **Workflow Structure:**
           - âœ… **Single Responsibility**: Each workflow should have one clear purpose
           - âœ… **Granular Activities**: Break complex operations into smaller activities
           - âœ… **Error Propagation**: Properly handle and propagate errors from activities
           - âœ… **Compensation Logic**: Implement rollback for failed workflow steps
           - âœ… **State Management**: Use workflow variables for state, not external storage


        **ğŸ“Š Error Handling & Resilience:**
        10. **Workflow Error Handling:**
            - âœ… **Try-Catch Blocks**: Wrap activity calls in proper error handling
            - âœ… **Retry Logic**: Implement workflow-level retry mechanisms
            - âœ… **Compensation**: Rollback completed steps on failures
            - âœ… **Error Propagation**: Return meaningful error information
            - âœ… **Logging**: Log errors with appropriate context and correlation IDs

        11. **Retry Strategies:**
            - âœ… **Exponential Backoff**: Use increasing delays between retries
            - âœ… **Jitter**: Add randomness to retry delays to prevent thundering herd
            - âœ… **Maximum Attempts**: Set reasonable limits on retry attempts
            - âœ… **Error Classification**: Different retry strategies for different error types
            - âœ… **Monitoring**: Track retry patterns and success rates



        **ğŸ“ˆ Observability & Monitoring:**
        12. **Metrics & Monitoring:**
            - âœ… **Workflow Metrics**: Track workflow execution times and success rates
            - âœ… **Activity Metrics**: Monitor activity performance and error rates
            - âœ… **Worker Metrics**: Track worker health and task processing rates
            - âœ… **Retry Metrics**: Monitor retry patterns and success rates
            - âœ… **Resource Usage**: Monitor memory, CPU, and connection usage

        13. **Logging & Tracing:**
            - âœ… **Structured Logging**: Use consistent log formats and field names
            - âœ… **Correlation IDs**: Include workflow and activity IDs in all logs
            - âœ… **Context Information**: Log relevant workflow state and parameters
            - âœ… **Error Details**: Include full error context and stack traces
            - âœ… **Performance Logging**: Log slow operations and bottlenecks

        **ğŸš¨ Common Anti-Patterns to Flag:**
        - âŒ Using system time or random numbers in workflows
        - âŒ Making direct I/O calls from workflows
        - âŒ Using global mutable state in workflows
        - âŒ Non-idempotent activities without idempotency keys
        - âŒ Missing timeout configurations for activities
        - âŒ No error handling or retry logic
        - âŒ Missing heartbeating for long-running activities
        - âŒ No monitoring or metrics implementation
        - âŒ Hardcoded retry policies or timeout values
        - âŒ Missing compensation logic for failed operations

        **ğŸ” Review Focus Areas:**
        - Verify workflow determinism and no side effects
        - Check activity idempotency and error handling
        - Ensure proper worker configuration and concurrency
        - Validate timeout and retry policy configurations
        - Review error handling and compensation logic
        - Check for monitoring and observability implementation
        - Identify opportunities for Prometheus metrics

        **ğŸ“Š Prometheus Metrics Opportunities:**
        - ğŸ” **Automatically suggest metrics when seeing:**
          - Workflow execution â†’ `temporal_workflows_total{workflow_type, status}`
          - Workflow duration â†’ `temporal_workflow_duration_seconds{workflow_type}`
          - Activity execution â†’ `temporal_activities_total{activity_type, status}`
          - Activity duration â†’ `temporal_activity_duration_seconds{activity_type}`
          - Worker metrics â†’ `temporal_worker_tasks_total{worker_id, status}`
          - Retry attempts â†’ `temporal_retries_total{operation_type, reason}`
          - Error handling â†’ `temporal_errors_total{type, operation}`
          - Timeout occurrences â†’ `temporal_timeouts_total{type, operation}`


  # =============================================================================
  # GLOBAL REVIEW INSTRUCTIONS
  # =============================================================================
  # 
  # These instructions apply to ALL code changes regardless of technology or path.
  # They serve as a comprehensive checklist for code quality, security, and best practices.
  # 
  # Teams can customize these instructions to match their specific:
  # - Coding standards and style guides
  # - Security requirements
  # - Testing policies
  # - Documentation standards
  # - Performance expectations
  global_instructions: |
    **ğŸ” General Code Review Checklist:**
    
    **ğŸ“ Code Quality:**
    - âœ… Functions and methods have clear, descriptive names
    - âœ… Complex logic is properly documented with comments
    - âœ… No hardcoded values or magic numbers
    - âœ… Error handling is comprehensive and appropriate
    - âœ… Code follows consistent formatting and style
    - âœ… No duplicate or redundant code
    - âœ… Proper separation of concerns
    
    **ğŸ”’ Security:**
    - âœ… No sensitive information (passwords, keys, tokens) in code
    - âœ… Input validation and sanitization where appropriate
    - âœ… Authentication and authorization checks are in place
    - âœ… No SQL injection vulnerabilities
    - âœ… No XSS vulnerabilities in web applications
    - âœ… Secure communication protocols (HTTPS, TLS)
    - âœ… Proper session management and timeout handling
    
    **ğŸ§ª Testing:**
    - âœ… New functionality has corresponding tests
    - âœ… Tests are meaningful and cover edge cases
    - âœ… Test names clearly describe what they're testing
    - âœ… No test code in production files
    - âœ… Tests are fast and reliable
    - âœ… Test coverage is adequate for critical paths
    - âœ… Integration tests for complex workflows
    
    **ğŸ“š Documentation:**
    - âœ… Public APIs are documented
    - âœ… Complex business logic has inline comments
    - âœ… README files are updated if needed
    - âœ… Configuration changes are documented
    - âœ… Architecture decisions are documented
    - âœ… Setup and deployment instructions are current
    
    **ğŸš€ Performance:**
    - âœ… No obvious performance bottlenecks
    - âœ… Database queries are optimized
    - âœ… Resource cleanup is handled properly
    - âœ… No memory leaks or resource leaks
    - âœ… Efficient data structures are used
    - âœ… Caching is implemented where appropriate
    - âœ… Async operations are used for I/O-bound tasks

  # =============================================================================
  # CODE QUALITY METRICS & THRESHOLDS
  # =============================================================================
  # 
  # These metrics help maintain code quality by flagging potential issues.
  # Thresholds can be adjusted based on your team's standards and project requirements.
  # 
  # Each metric includes:
  # - threshold: The value that triggers a review comment
  # - enabled: Whether this metric is active
  # - instructions: Explanation of why the threshold matters and how to address it
  metrics:
    # Function complexity measures the number of decision points in a function
    # Higher complexity makes code harder to understand, test, and maintain
    function_complexity:
      threshold: 15        # Cyclomatic complexity > 15 triggers review
      enabled: true
      instructions: |
        Functions with cyclomatic complexity > 15 should be refactored into smaller,
        more focused functions for better maintainability and testability.
        
        COMPLEXITY FACTORS:
        - if/else statements
        - switch cases
        - loops (for, while, do-while)
        - logical operators (&&, ||)
        - catch blocks
        
        REFACTORING STRATEGIES:
        - Extract complex conditions into well-named boolean functions
        - Split large functions into smaller, focused functions
        - Use early returns to reduce nesting
        - Consider using strategy pattern for complex logic

    # Function length measures the number of lines in a function
    # Longer functions are harder to understand and maintain
    function_length:
      threshold: 150       # Functions > 150 lines trigger review
      enabled: true
      instructions: |
        Functions longer than 150 lines should be broken down into smaller,
        more focused functions for better readability and maintainability.
        
        REFACTORING STRATEGIES:
        - Extract logical blocks into separate functions
        - Use helper functions for repetitive code
        - Consider breaking into multiple smaller functions
        - Use classes/structs to group related functionality
        
        EXCEPTIONS:
        - Data processing functions that must process large datasets
        - Generated code (though this should be minimized)
        - Legacy code that's being gradually refactored

    # File length measures the total lines in a file
    # Very long files can be hard to navigate and understand
    file_length:
      threshold: 500       # Files > 500 lines trigger review
      enabled: true
      instructions: |
        Files longer than 500 lines should be considered for splitting into
        multiple files or modules for better organization.
        
        SPLITTING STRATEGIES:
        - Group related functionality into separate files
        - Extract utility functions into shared modules
        - Split large classes into multiple smaller classes
        - Create separate files for different concerns
        
        ORGANIZATION TIPS:
        - Keep related functionality together
        - Use clear file naming conventions
        - Consider using packages/modules for organization
        - Maintain logical separation of concerns

    # Nesting depth measures how deeply code is nested
    # Deep nesting makes code hard to read and understand
    nesting_depth:
      threshold: 4         # Nesting > 4 levels triggers review
      enabled: true
      instructions: |
        Code with nesting depth > 4 levels should be refactored to reduce
        complexity and improve readability.
        
        NESTING REDUCTION TECHNIQUES:
        - Use early returns to avoid deep nesting
        - Extract complex conditions into boolean functions
        - Use guard clauses at the beginning of functions
        - Consider using switch statements instead of if-else chains
        - Break complex logic into smaller functions
        
        EXAMPLE REFACTORING:
        ```go
        // Before (deep nesting)
        if user != nil {
            if user.IsActive() {
                if user.HasPermission("read") {
                    if data != nil {
                        // process data
                    }
                }
            }
        }
        
        // After (early returns)
        if user == nil || !user.IsActive() || !user.HasPermission("read") {
            return errors.New("unauthorized")
        }
        if data == nil {
            return errors.New("no data")
        }
        // process data
        ```

  # =============================================================================
  # REVIEW BEHAVIOR CONFIGURATION
  # =============================================================================
  # 
  # These settings control how CodeRabbit behaves during reviews.
  # Adjust these based on your team's preferences and workflow requirements.
  behavior:
    # Review scope determines which files are included in reviews
    review_all_files: true        # Review all changed files
    review_test_files: true       # Include test files in reviews
    review_documentation: true    # Review documentation changes
    
    # Comment behavior controls how CodeRabbit provides feedback
    suggest_fixes: true           # Suggest specific fixes for issues
    explain_why: true             # Explain why changes are suggested
    
    # Review depth controls the thoroughness of reviews
    thoroughness: "high"          # Options: "low", "medium", "high"
    focus_on_critical: true       # Prioritize critical issues
    
    # Language and framework awareness
    language_agnostic: true       # Work with any programming language
    framework_aware: true         # Understand framework-specific patterns

  # =============================================================================
  # SECURITY SCANNING CONFIGURATION
  # =============================================================================
  # 
  # Security scanning helps identify potential security vulnerabilities
  # and ensures code follows security best practices.
  security:
    enabled: true                 # Enable security scanning
    scan_dependencies: true       # Check for vulnerable dependencies
    scan_secrets: true            # Detect hardcoded secrets
    scan_vulnerabilities: true    # Identify security vulnerabilities
    
    # Security rules define specific security checks
    rules:
      - name: "no_hardcoded_secrets"
        enabled: true
        severity: "high"          # Critical security issue
        description: |
          Detect hardcoded passwords, API keys, tokens, or other sensitive
          information that should be stored in environment variables or
          secure configuration management systems.
        
      - name: "input_validation"
        enabled: true
        severity: "medium"        # Important security consideration
        description: |
          Ensure all user inputs are properly validated and sanitized
          to prevent injection attacks and data corruption.
        
      - name: "authentication_checks"
        enabled: true
        severity: "high"          # Critical security requirement
        description: |
          Verify that proper authentication mechanisms are in place
          for all protected resources and operations.
        
      - name: "authorization_checks"
        enabled: true
        severity: "high"          # Critical security requirement
        description: |
          Ensure that authorization checks are performed to verify
          users have permission to access specific resources.

# =============================================================================
# CONFIGURATION NOTES & CUSTOMIZATION GUIDE
# =============================================================================
#
# This base configuration provides a solid foundation for most projects.
# However, you may want to customize it based on your specific needs:
#
# 1. ADJUSTING THRESHOLDS:
#    - Modify the values in the metrics section based on your team's standards
#    - Consider your project's complexity and team experience level
#    - Start with conservative thresholds and adjust based on feedback
#
# 2. ADDING CUSTOM LABELS:
#    - Add new labels to the labeling_instructions section
#    - Provide clear, specific criteria for when to apply each label
#    - Include examples to help CodeRabbit make accurate suggestions
#
# 3. CUSTOMIZING GLOBAL INSTRUCTIONS:
#    - Modify global_instructions to match your team's coding standards
#    - Add project-specific requirements or guidelines
#    - Include links to your style guides or documentation
#
# 4. SECURITY REQUIREMENTS:
#    - Adjust security rules based on your application's security needs
#    - Add industry-specific security requirements
#    - Consider compliance requirements (SOC2, HIPAA, GDPR, etc.)
#
# 5. PERFORMANCE EXPECTATIONS:
#    - Modify performance thresholds based on your application's requirements
#    - Consider your infrastructure and user expectations
#    - Add performance monitoring and alerting requirements
#
# For more information and examples, see the README.md file and the
# technology-specific configuration files in the configs/ directory.

